# 자바 기본

## Primitive Type과 Reference Type의 차이점

자바에서 데이터 타입은 크게 Primitive Type과 Reference Type으로 나눌 수 있다. 

**Primitive Type(원시 타입)**

- 정수, 실수, 문자, 논리 리터널 등의 실제 데이터 값을 저장하는 타입이다.
- int, long, double, float, boolean, byte, short, char
- Java에서 기본 자료형은 반드시 사용하기 전에 선언되어야하며, 자료형의 길이는 운영체제에 독립적이며 변하지 않는다.
- Stack 메모리에 저장된다.

**Reference. Type(참조 타입)**

- 객체를 참조하는 타입으로 메모리 번지 값을 통해 객체를 참조하는 타입이다.
- Integer, Long, Double, Float, Boolean, Byte, Short, Char
- Java에서 최상위 클래스인 Object 클래스를 상속하는 모든 클래스를 말한다.
- Java에서 실제 객체는 Heap 메모리에 저장되며 참조 타입 변수는 스택 메모리에 실제 객체들의 주소를 저장하여 객체를 사용할 때마다 참조 변수에 저장된 객체의 주소를 불러와 사용하는 방식이다.

************차이점************

- 원시 타입은 null 값을 담을 수 없는 반면에 참조 타입은 null을 입력 값으로 받을 수 있다.
- 원시 타입은 제네릭 타입에서 사용할 수 없는 반면에 참조 타입은 제네릭 타입에서 사용할 수 있다.

## 접근 제어자

자바에서는 접근 제어자를 사용하여 클래스의 멤버(필드, 메서드, 내부 클래스)에 대한 접근 권한을 제어할 수 있다. 접근 제어자는 코드의 캡슐화와 데이터 은닉을 지원하며, 다른 클래스나 패키지에서 어떤 멤버에 접근할 수 있는지를 명시적으로 정의한다.

1. **public**
    - 가장 넓은 범위의 접근 제어자로, 어떤 클래스에서든 접근이 가능하다. 다른 패키지에서도 접근할 수 있다.
2. **protected**
    - 같은 패키지 내의 클래스와 해당 클래스를 상속받은 서브클래스에서 접근 가능하다. 다른 패키지의 클래스에서는 접근이 제한된다.
3. **default**
    - 접근 제어자를 명시하지 않는 경우, 해당 멤버는 기본적으로 같은 패키지 내에서만 접근이 가능하다. 다른 패키지에서는 접근할 수 없다.
4. **private**
    - 가장 제한적인 범위의 접근 제어자로, 해당 멤버는 오로지 자신을 포함한 해당 클래스 내에서만 접근 가능하다. 서브 클래스도 접근할 수 없다.

## static

Java에서 Static 키워드를 사용하는 것은 메모리에 한 번 할당되어 프로그램이 종료될 때  해제되는 것을 의미한다.

Static 키워드를 통해 생성된 정적멤버들은 Heap 영역이 아닌 Static영역에 할당된다. Static 영역에 할당된 메모리는 모든 객체가 공유하여 하나의 멤버를 어디서든지 참조할 수 있는 장점을 가지지만 Garbage Collector의 관리 영역 밖에 존재하기에 Static 영역에 있는 멤버들은 프로그램의 종료시까지 메모리가 할당된 채로 존재하게 된다.

**************************************************정적(Static) 멤버 선언**************************************************

```java
static int num = 0;
public static void static_method(){}
```

## final

자바(Java)에서 final 키워드는 변수, 메서드, 클래스 등의 선언 앞에 사용된다. final은 다양한 컨텍스트에서 다른 의미를 가지며, 주로 해당 멤버나 클래스의 수정이나 재정의를 막는 데 사용된다.

1. **Final 변수**
    - final로 선언된 변수는 상수를 나타낸다. 즉, 한 번 초기화되면 값을 변경할 수 없다.
    - 초기화는 변수를 선언할 때 또는 생성자에서 이루어져야 한다.
    - 주로 상수 값이나 설정 값을 표현할 때 사용된다.
2. **Final 메서드**
    - final로 선언된 메서드는 하위 클래스에서 재정의(오버라이딩)할 수 없다.
    - 부모 클래스에서 정의된 메서드가 그대로 사용되어야 하며, 하위 클래스에서 변경할 수 없다.
3. **Final 클래스**
    - final로 선언된 클래스는 더 이상 상속될 수 없다. 즉, 하위 클래스를 만들 수 없다.
    - 주로 불변 클래스를 정의할 때 사용된다. 불변 클래스란 수정할 수 없는 객체를 나타낸다.
4. **Final 매개변수**
    - 메서드나 생성자의 매개변수를 final로 선언할 수 있다.
    - final 매개변수는 메서드 내에서 변결할 수 없으며, 주로 메서드 내에서 매개변수 값이 변경되지 않음을 보장할 때 사용된다.
5. **Final 변수와 상속**
    - final로 선언된 변수는 재할당할 수 없지만, 상속 관계에서 주의해야 함.
    - 부모 클래스의 final 변수는 하위 클래스에서 다시 선언하여 새로운 변수로 인식된다.
    
    ```java
    public class Parent {
        final int value = 10;
    }
    
    public class Child extends Parent {
        // 부모 클래스의 value와는 별개의 변수
        final int value = 20;
    }
    ```
    

## Overloading, Overriding

오버로딩과 오버라이딩 두 개념은 다형성을 구현하는 데 사용된다.

1. **Overloading**
    - 오버로딩은 같은 이름의 메서드 또는 생성자를 여러 개 정의하는 것을 의미한다.
    - 오버로딩된 메서드는 매개변수의 타입, 개수 또는 순서가 서로 다를 수 있다.
    - 호출 시 인자의 종류나 개수에 따라 적절한 오버로딩된 메서드가 선택되어 실행된다.
    
    ```java
    public class Example {
        public int add(int a, int b) {
            return a + b;
        }
        
        public double add(double a, double b) {
            return a + b;
        }
        
        public String add(String a, String b) {
            return a + b;
        }
    }
    ```
    
2. **Overriding**
    - 오버라이딩은 상위 클래스(부모 크래스)의 메서드를 하위 클래스(자식 클래스)에서 재정의하는 것을 의미한다.
    - 매서드 시그니처(메서드 이름, 매개변수 타입 및 반환 타입)는 동일해야 한다.
    - 오버라이딩된 메서드는 상위 클래스의 메서드 대신 호출된다. 이렇게 하위 클래스에서 동일한 메서드 이름으로 다르게 동작하도록 할 수 있다.
    
    ```java
    class Animal {
        void makeSound() {
            System.out.println("동물이 소리를 내고 있습니다.");
        }
    }
    
    class Dog extends Animal {
        @Override
        void makeSound() {
            System.out.println("강아지가 짖고 있습니다.");
        }
    }
    ```
    
- 오버로딩은 같은 클래스 내에서 메서드 이름이 같은 다수의 메서드를 가질 수 있으며, 메서드 호출 시 매개변수에 따라 어떤 메서드가 호출될지 결정됩니다.
- 오버라이딩은 상속 관계에서 발생하며, 상위 클래스의 메서드를 하위 클래스에서 덮어쓰는 것을 의미합니다. 오버라이딩된 메서드는 상위 클래스의 메서드를 대체하고 동일한 시그니처를 가져야 합니다. 호출 시 객체의 타입에 따라 오버라이딩된 메서드가 실행됩니다.

## 추상 클래스와 인터페이스

****************추상 클래스 (Abstract Class)****************

- 추상 클래스는 일반 클래스와 별 다를 것이 없다. 단지, 추상 메서드를 선언하여 상속을 통하여 자손 클래스에서 완성하도록 유도하는 클래스이다. 그래서 미완성 설계도라고도 표현한다.
- 상속을 위한 클래스이기 때문에 따로 객체를 생성할 수 없다.

```java
abstract class 클래스이름 {
    ...
    public abstract void 메서드이름();
}
```

**인터페이스 (Interface)**

- 인터페이스는 기본 설계도이다. 인터페이스는 클래스에 특정 동작을 추가하고, 다양한 클래스 간에 공통 동작을 정의하기 위해 사용된다.
- 다중상속이 가능하다.

```java
interface 인터페이스이름 {
    public static final 상수이름 = 값;
    public abstract void 메서드이름();
}
```

**차이점**

1. 인스턴스 생성 가능 여부
    - 추상 클래스는 인스턴스를 직접 생성할 수 있다. 즉, 객체를 만들 수 있다
    - 인터페이스는 직접 인스턴스를 생성할 수 없다. 즉, 객체를 만들 수 없으며, 인터페이스를 구현한 클래스의 인스턴스를 생성해야 한다.
2. 메서드
    - 추상 클래스는 추상 메서드(Abstract Method) 외에도 구현된 메서드(일반 메서드)를 포함할 수 있다. 추상 메서드는 하위 클래스에서 반드시 구현되어야 하지만, 일반 메서드는 구현되어 있어도 되고 하위 클래스에서 오버라이딩(재정의)할 수 있다.
    - 인터페이스는 추상 메서드만을 선언할 수 있습니다. 모든 메서드는 추상이며, 이를 구현하는 클래스에서 반드시 모든 메서드를 구현해야 합니다.
3. 상속
    - 자바에서 클래스는 하나의 클래스만 상속할 수 있으므로, 추상 클래스는 다른 클래스를 상속받으면서 동시에 추상 클래스일 수 있습니다.
    - 클래스는 하나의 클래스만 상속할 수 있지만, 인터페이스는 여러 인터페이스를 동시에 구현할 수 있으므로 다중 상속을 지원합니다.

## Enum

Java에서 `**Enum**`은 열거형(Enumeration)을 나타내는 데이터 형식으로, 관련된 상수를 그룹화하고 간편하게 사용할 수 있도록 지원하는 기능이다.

```java
enum 이름 {
    상수1,
    상수2,
    // ...
}
```

## 객체지향이란?

객체 지향 프로그래밍 (Object-Oriented Programming, OOP)은 프로그래밍에서 필요한 데이터를 추상화 시켜 `상태와 행위를 가진 객체`로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.

객체지향 프로그래밍의 ******이점******

1. **모듈화(Modularity):** 객체지향 프로그래밍은 코드를 모듈화하고 클래스로 구성함으로써 코드의 유지보수성을 높인다. 각 클래스는 독립적으로 개발 및 테스트할 수 있어서 개발 과정을 단순화한다.
2. **재사용성(Reusability):** 상속과 다형성을 활용하여 코드를 재사용할 수 있다. 이미 구현된 클래스를 확장하여 새로운 클래스를 작성하거나, 다른 프로젝트에서 동일한 클래스를 사용할 수 있다.
3. **유지보수성(Maintainability):** 객체 지향 프로그래밍은 코드를 더 쉽게 이해하고 수정할 수 있도록 도와준다. 클래스와 객체의 캡슐화는 내부 구현을 숨기고 외부 인터페이스를 통해 상호작용하기 때문에 코드 변경이 다른 부분에 미치는 영향을 최소화한다.
4. **확장성(Scalability):** 객체지향 시스템은 요구 사항의 변화나 추가 기능의 구현에 대한 확장성을 가진다. 새로운 클래스나 객체를 추가하고 기존 코드를 수정하지 않고도 시스템을 확장할 수 있다.
5. **코드의 가독성과 이해도 향상:** 현실 세계 개념을 모델링하므로 코드는 비즈니스 로직을 이해하기 쉽고 자연스럽게 문서화된다.
6. **객체 재사용:** 객체를 독립적으로 개발하여 라이브러리로 사용하거나 다른 프로젝트에서 재사용할 수 있으므로 생산성이 향상된다.

## 객체지향의 4대 특성

1. **캡슐화(Encapsulation):**
    - 캡슐화는 데이터와 해당 데이터를 처리하는 메서드를 하나로 묶어 객체로 생성하는 것을 의미한다.
    - 객체의 상태(데이터)는 private 접근 제어자를 사용하여 외부에서 직접 접근할 수 없게 제한된다. 따라서 정보 은닉(Information Hiding)을 실현한다.
    - 오직 객체의 메서드를 통해서만 데이터에 접근할 수 있으므로 데이터의 무결성을 보호하고 부적절한 수정을 방지할 수 있다.
2. **상속(Inheritance):**
    - 상속은 하위 클래스가 상위 클래스의 특성과 동작을 상속받아 재사용할 수 있도록 하는 메커니즘이다.
    - 상속 관계를 형성하여 클래스 간 계층 구조를 생성하고, 공통 코드를 공유하여 코드의 재사용성을 향상시킨다.
    - 상위 클래스는 기본적인 동작을 정의하고, 하위 클래스는 이를 확장하거나 변경할 수 있다.
3. **다형성(Polymorphism):**
    - 다형성은 하나의 인터페이스나 메서드를 여러 클래스에서 다르게 구현하는 능력을 의미한다.
    - 다형성을 통해 객체가 여러 형태를 가질 수 있고, 실행 시간에 객체의 실제 타입에 따라 다른 메서드가 호출된다.
    - 다형성은 코드의 유연성을 높이고, 동적 바인딩을 통해 실행 시간에 적절한 메서드를 호출한다.
4. **추상화(Abstraction):**
    - 추상화는 복잡한 시스템을 간소화하고 필수적인 기능만 포함하는 모델을 생성하는 과정이다.
    - 추상 클래스와 인터페이스를 사용하여 현실 세계의 개념을 모델링하고, 중요한 세부 정보를 감추어 간결하고 이해하기 쉬운 인터페이스를 제공한다.
    - 추상화를 통해 사용자는 객체의 핵심 기능에만 집중할 수 있으며, 세부 구현을 무시할 수 있다.

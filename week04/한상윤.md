# 4주차

# **4주차 학습 PR**

이번 주의 메인 테마는 테스트입니다. 단위 테스트와 테스트 툴인 JUnit5, AssertJ를 공부하고, 로또 미션에 충분한 테스트를 작성해주세요! 많은 예시 코드를 보시면 금방 감이 오실 겁니다!

- 테스트 코드란? 테스트 코드는 왜 작성하는지?
- 단위 테스트란?
- JUnit5, AssertJ란?
- BDD란?
- private method test
- @ParameterizedTest
- 참고하면 좋을 것 같은 링크
- [https://youtu.be/mIO4Rbe_M74?feature=shared](https://youtu.be/mIO4Rbe_M74?feature=shared)
- [https://tecoble.techcourse.co.kr/post/2021-05-25-unit-test-vs-integration-test-vs-acceptance-test/](https://tecoble.techcourse.co.kr/post/2021-05-25-unit-test-vs-integration-test-vs-acceptance-test/)

### 테스트 코드란? 테스트 코드는 왜 작성하는 지?

소프트웨어의 기능과 동작을 테스트하는 데  사용되는 코드이다. 소프트웨어의 기능을 부분적으로 확인할 수 있게 해준다. 테스트 코드는 개발자가 작성한 코드를 실행하고 그 코드에 대한 예상한 결과 값과 일치하는 지 확인한다.
우리가 전체 프로그램에서 특정 부분이 잘 실행되는 것에 대한 확인은 직접 실행을 통해 확인할 수 있지만,  후반부에 존재하는 소스코드를 확인하기 위해선 앞에 존재하는 소스코드가 다 실행을 해야 확인 할 수 있다. (초반부에 나오는 아이디, 비밀번호 입력하기를 매번 입력해야하는 것처럼). 그렇기 때문에 테스트 코드는 내가 확인하고 싶은 부분을 바로 확인 시켜주는 역할을 한다.

추가로 리팩토링이라는 작업을 할 때, 올바르게 리팩토링이 되었는 지도 확인을 해야한다. 왜냐하면 리팩토링은 결과의 변화없이 코드의 구조를 변경하는 것인데 결과가 이상해지면 안되기 때문이다. 그때 이미 만들어진 테스트 코드를 이용한다면, 리팩토링이 올바르게 됐는 지 빠르게 확인 할 수 있다.

### 단위테스트란?

테스트 코드에는 단위테스트, 통합 테스트, 인수 테스트등 여러 종류가 존재한다. 

1. 단위 테스트 
: 단위 테스트란 응용프로그램에서 테스트 가능한 가장 작은 단위의 소프트웨어를 실행해서 제대로 동작하는 지 확인하는 테스트이다. 가장 작은 단위라고 함은 함수 나 메서드 정도의 수준을 의 미  한다. 객체가 가진 하나의 기능 정도를 테스트한다고 본다. 단위의 크기가 작을 수록 복잡도가 낮아지기 때문에 빠르고 간단한 테스트 코드가 될 수 있다. (FIRST 규칙)
단위 테스트 코드를 짜기 위해선 소스 코드의 로직이나, 의미, 어떻게 돌아가는 지를 알아야 한다. 이것을 화이트 박스 테스트라고 한다. 
단위 테스트는 TTD와 함께 할 때 강력하다.’

※TTD
Test Driven Development의 약자로, 테스트가 개발을 주도한다는 의미를 가지고 있다. 짧은 개발 주기의 반복을 가지고 있는 애자일 방법론 중의 하나이고 Test-First라는 개념에 기반을 둔 단순한 설계를 중시한다. 
TTD의 개발 주기는 실패할 것 같은 상황에 대한 테스트 코드를 짠다. 그 다음에 그것을 통과하는 실제 소스코드를 짠다. 그 다음 중복 코드 제거, 일반화등의 리펙토링을 한다. 이 3가지 단계를 통해 기능을 만들어낸다. 여기서 중요한 점은 테스트코드를 짜기 전까지 실제 코드를 구현하지 않는 것이다. 
일반 개발 방식은 요구사항 수집 → 설계 → 분석 → 개발 → 테스트 → 배포의 형태를 가진다. 하지만 이러한 방식은 개발 속도를 늦추는 변수들이 존재한다. 요구사항이 처음부터 완벽할 수 없어서 완벽한 설계는 이미 못하고, 또 이미 개발한 상태에서 나올만한 에러를 찾는 것도 힘들고 에러를 찾고 그것을 그때 수정하는 것도 유지 보수적인 비용이 늘어난다고 볼 수 있다.
TTD 개발 방식은 디자인 → 테스트 코드 작성 → 코드 개발 → 리팩토링의 형태를 가진다.
이렇게 된다면, 자연스럽게 구현된 코드의 버그가 줄어들고 자연스럽게 설계가 되고, 나중에 에러를 찾는 데에 큰 어려움을 격지 않아도 된다.

2. 통합 테스트
: 서로 다른 모듈들 간의 상호작용을 확인하기 위한 테스트 코드이다. 단위 테스트보단 큰 단위를 테스트하며 서로 상호작용이 잘 이루어 지는 지 확인하는 것이다.
이것은 소스 코드끼리의 관계만을 확인하는 것이 아니라, 라이브러리, 실행되는 환경, 올바른 DB 연결, 이러한 변수들도 확인을 할 수 있다. 전체 코드가 다양한 환경에서 제대로 작동되는 지 확인하는 데 필요한 작업을 다 검토할 수 있다. 하지만 통합테스트가 무조건 응용프로그램으로 완벽하다는 것을 증명하지 않는다.
이것을 사용함으로써 단위 테스트에서 찾기 어려운 버그들을 찾을 수 있다. 하지만 단점으로는 단위 테스트보다 확실히 복잡하기 때문에, 완벽하게 테스트했다는 신뢰성이 떨어지고, 어디서 버그가 났는 지 정확하게 찾기는 힘들다.  

3. 인수 테스트
: 사용자 스토리(시나리오)에 맞춰서 잘 수행하는 지 확인하는 테스트이다. 즉 사용자가 이것을 어떻게 사용할 것인가에 따라 테스트 코드가 작성이 된다. 
이것은 프로젝트에 참여하는 사람들(기획자, 클라이언트 대표, 개발자)가 토의해서 시나리오를 구상하고 그것대로 코드가 잘 짜여졌는 지 확인하는 테스트 코드인 것이다. (이렇게 사람들한테시나리오를 인수 받아서 짠 테스트라고 해서 인수 테스트이다.)
함수가 잘 작동되고, 실행이 잘 되냐 보다는 비즈니스 적인 설계대로 잘 흘러가는 지를 확인한다.
시나리오에서 중요한 것은 “누가, 어떤 목적으로, 무엇을 하는 가” 이다. 그리고 이러한 것들은 API를 통해 드러난다.  요청이 들어왔을 때 올바른 값이 반환됐는 지를 보는 것이기에  소스코드가 어떤지는 보지 않는 블랙박스 테스트라고 볼 수 있다.

### JUnit5, AssertJ란?

1. JUnit5
JUnit5란 자바에서 테스트를 하기위해 사용되는 테스팅 프레임 워크이다. JUnit은 여러 버전이 존재하고 JUnit5는 JUnit4를 향상시켜서 나온 버전이다. 이 버전은 Java 버전8 이상부터 사용이 가능하다.
JUnit5는 3가지 주요 모듈을 구성되어 있다.
- JUnit Platform : 테스트 엔진을 실행하는 런처와 TestEngine API를 제공한다.
- Jupiter : TestEngine API 구현체로 JUnit5에서 제공한다.
-JUnit Vintage : 이전 버전의 JUnit으로 작성된 테스트를 지원하는 호환성 모듈을 제공한다. 
⇒ Platform은 테스트 환경을 설정하고 관리하는 역할이다. 어떻게 TestEngine을 다룰지에 대한 정보가 담겨있고, 실제 테스트를 정의하고 그것을 실행하는 역할은 Jupiter이다. Jupiter에는 다양한 어노테이션과 테스트 메타데이터를 포함하고, 테스트를 실행하고, 그 결과를 리포트로 제공한다. Vintage일 경우 이전 버전에서 사용했던 JUnit을 사용할 수 있게 해주는 역할일 뿐이다.
**즉 “Platform은 환경, Jupiter는 실제로 테스트 실행, Vintage는 예전 거 호환되게 하기 위해서” 맞는 지 궁금해요!**
(IDE나 빌드도구에서 JUnit Platform을 지원한다.)

- JUnit5가 제공하는 어노테이션
1️⃣ @Test : 해당 메서드가 Test인 것을 나타낸다. JUnit5는 Test 어노테이션이 지정된 모든 메서드를 검색하고 그것을 개별적인 테스트 메서드로 분리 해놓는다. 그리고 그것은 Test Runner라는 실행 엔진을 사용하여 실행이 된다.
2️⃣ @BeforeEach : 각각의 테스트 메서드 실행전에 실행되어야 하는 코드를 정의해놓는다.
이것은 BeforeEach가  붙은 메서드를 포함하는 클래스 내부의 Test로 지정된 메서드에 다 적용이 된다.
3️⃣ @AfterEach : 각각의 테스트 메서드 실행 후에 실행되어야 하는 코드를 정의한다.
여기에는 리소스 해제나, 임시 파일을 삭제하는 등의 코드가 존재한다.
4️⃣ @BeforeAll : 모든 테스트가 시작하기 전에 한번 만 실행되어야 하는 코드를 정의한다.
데이터 베이스 연결이라든지,  설정을 로딩한다는 지에 대한 코드가 존재한다.
5️⃣ @AfterAll : 모든 테스트가 메서드 실행 후에 한번 ㅁ나 실행되어야 하는 코드를 정의한다.
여기에도 리소스 해제나, 임시 파일을 삭제하는 코드가 존재한다.
- JUnit5가 제공하는 메서드
assertEquals(expected, actual), assertSame(expected, actual),assertTrue(condition) 등 이런 메서드가 존재하지만, AssertJ의 메서드를 사용하는 것이 더 가독성이 좋고, 어떤 테스트가 어떤 문제가 발생했는 지에 대한 더 자세한 정보를 주기 때문에 Assert의 메서드를 사용한다.
2. AssertJ란
자바에서 사용되는 테스트 단언 라이브러리이다. 단언은 테스트 코드에서 기대하는 결과를 확인하고 검증하는 데 사용되는 코드이다. 주요 특징으로는
- 인간 친화적인 문법 : 자연어에 가까운 문법을 사용해서 쉽게 이해할 수 있다.
- 다양한 비교를 할 수 있다. : `**isEqualTo(), isNotEqualTo(),isGreaterThan(), contain()**`등을 활용하여 값비교, 컬렉 검증, 문자열 패턴 일치 여부를 확인 할 수 있다.
1) **`isEqualTo()`**: 두 객체 또는 값이 서로 동일한지 확인한다. 객체 또는 값이 서로 같은지 확인할 때 사용된다..
    
    2) **`isNotEqualTo()`**: 두 객체 또는 값이 서로 다른지 확인한다. 객체 또는 값이 서로 다른지 확인할 때 사용된다.
    
    3) **`isGreaterThan()`**: 값이 주어진 값보다 큰지 확인한다. 주로 숫자 또는 순서를 비교할 때 사용된다.
    
    4) **`contains()`**: 컬렉션(리스트, 집합 등)이 특정 요소를 포함하는지 확인한다. 특정 요소가 컬렉션에 존재하는지 확인할 때 사용된다.
    
    → 여기서 말하는 비교는 미리 정해놓은 값과 소스코드상에서의 결과를 비교하는 것이다.
    
    그리고 체인 형식의 메서드 호출로 가독성이 좋고 또 위에서 말했다 싶이, 어떤 테스트에서 어떤 문제로 인해 실패했는 지에 대한 정보를 더 많이 준다.


![Untitled](https://github.com/COW-edu/COW-Spring-2/assets/120346721/5999856a-9a27-4375-82b2-37a5769cc8e0)
    

### BDD란

Behavior Driven Development로써 행동 주도 개발 프로세스이다. 이것은 TDD을 기반으로 개발론이다. TDD와의 차이점은 TDD는 단위 테스트를 중점으로, 어떤 기능,모듈을 만들 때 그것에 대한 테스트 코드를 짜고 실제 코드를 구현하는 것이였다. 하지만 이것은 인수테스트를 중점으로 기능보다는 기획과 설계에 대한 테스트를 중점으로 둔다. 비즈니스적인 시나리오가 제대로 동작하는 지, 거기서 발생할 버그같은 것을 잡는 테스트 코드를 짜는 것이다. 이것을 통해 전체적인 프로그램의 기획과 설계를 정하면서 테스트 코드를 짜고 실제 코드르 짜기 때문에 유지보수적인 면에서 좋다.
이러한 방식을 Outside-in방식이라고 하며 외부부터 내부로 개발하는 방식을 의미한다. 

이 방식은 개발자나, 기획자 이런 상호작용이 효과적으로 이루어지기 때문에 이해도가 올라갈 수 있다.

TDD와 BDD를 분리해서 사용하는 것이 아니라, 서로 상호보완적인 관계로 기능은 TDD로 개발하고 전체 시나리오는 BDD 방식으로 구현하는 것이 효과적이다.


![Untitled 1](https://github.com/COW-edu/COW-Spring-2/assets/120346721/05a5f99b-810b-4db0-b553-a45abe7e05c1)

### Private method test

특정 메서드를 테스트할 때 만약 그 메서드가 Private 메서드라면 어떻게 Test를 해야할까?

private 메서드일 경우 해당 클래스내에서만 호출이 가능하기 때문에 테스트에서 접근할 수 없다.

그럴 때 사용되는 방법은  자바 Reflection API를 이용해서 private 메서드의 접근을 허용으로 바꾼 다음에 테스트하는 것이다.
자바는 클래스나 메소드의 메타 정보들을 위한 클래스나 메서드를 정의해 놓았다. reflection을 활용한다면, 존재하는 클래스에 존재하는 정적으로 고정된 메서드의 코드를 메타 정보로 추상화된 메서드를 얻을 수 있고 심지어 직접 호출까지도 가능하다. 그렇게 추출한 메서드에 `.setAccesible(true)`를 해주면 테스트에서도 접근이 가능하여 테스트 할 수 있게 된다. 
리플렉션은 런타임에 동적으로 작동하는 기능으로서 프로그램을 유연하게 만들 수 있다. 하지만 private으로 클라이언트와 결합도를 낮췄는 데, 이런식으로 결합도를 높이게 된다면, 유지보수할 때 테스트에 대해서도 리팩토링이 일어날 수 밖에 없다. 메서드 이름이 바뀐다든지, 파라미터가 바뀌는 변화가 있을 때 테스트 코드도 변화되어야 하고, 신경이 쓰여진다. 그렇기 때문에 리플렉션 사용으로 PrivateMethod test는 지양해야하고, 꼭 필요하다면 사용할 때만 사용하든 지 아니면 public한 메서드만을 테스트하고 private 메서드가 테스트에 포함되어 있다면 그 메서드를 사용하는 것이 아닌 그 메서드를 사용했을 때의 경우의 수로 각각 테스트를 만드는 방법도 존재한다.

### @ParameterizedTest

단위 테스트에서 여러 다른 매개 변수를 사용해서 같은 코드를 반복적으로 테스트 할 때 유용한 애너테이션이다. 여러 개의 값을 한 개의 테스트에서 검증할 수 있게 된다. 
ParameterizedTest는 @ValueSource, @EnumSourse, @MethodSourse등의 에너테이션과 함께 사용된다. 

1. @ValueSource
: 단일 파라미터를 받는 테스트에 사용된다. 여러 개의 리터럴 값인 숫자, 문자등을 제공할 때 사용된다. @valueSource는 고정된 값들만 파라미터로 제공한다. 그렇기 때문에, 런타임에 계산되는 랜덤 값이나 메서드 호출 결과 등을 넣진 않는다.
2. @EnumSourse 
: Enum 타입을 파라미터로 받고, Enum 클래스의 모든 상수 값을 인자로 제공한다.
3. @MethodSourse
: 함수 이름을 파라미터로 받는 다. 해당 함수가 반환하는 값들을 테스트 인자로 사용한다. 이때 반환 타임은 Stream, Iterable이여야 한다.

![Untitled 2](https://github.com/COW-edu/COW-Spring-2/assets/120346721/1ca85f65-c64a-479b-927d-9d7cbccc08ec)

→ 애너테이션에서 파라미터를 받고, 메서드의 파라미터는 기본형 타입이 올 수도 있고, 객체 참조도 사용될 수 있다.

참조

[https://yozm.wishket.com/magazine/detail/1964/](https://yozm.wishket.com/magazine/detail/1964/)

[https://mingule.tistory.com/43](https://mingule.tistory.com/43)
# 4주차 학습 PR

* 테스트 코드란? 테스트 코드는 왜 작성하는지?
  테스트 코드는 소프트웨어의 기능과 동작을 테스트하는 코드이다. 테스트 코드를 통해 코드가 개발자가
  원하는 대로 작동하는 지를 확인할 수 있다. 테스트 코드 작성을 통해 요구사항을 정리하며 문서 역할을
  할 수 있으며 리펙토링 시에도 테스트를 통해 기능이 변질되지 않고 정상적으로 작동하는지 쉽게 확인하여
  부담을 줄일 수 있다.
  좋은 테스트 코드는 FIRST라는 5가지 규칙을 따른다.
  Fast: 테스트는 빠르게 동작한다.
  Independent: 각각의 테스트는 독립적이다.
  Repeatable: 어느 환경에서든 반복 가능해야 한다.
  Self-Validation: 테스트는 성공 또는 실패로 결과를 내어 검증되어야 한다.
  Timely: 테스트는 적시에, 코드 구현 전 구현해야 한다.
  
* 단위 테스트란?
  단위 테스트는 실행가능한 최소 단위의 모듈에 대한 테스트를 하는 것이다. 모듈은 함수 혹은 기능으로
  해석할 수 있다. 이러한 모듈에 대하여 테스트 코드를 작성하여 정확한 입력값과 출력값을 반환하는 지
  확인할 수 있다. 모듈 간의 호환성을 확인하는 통합 테스트와 달리 단위 테스트는 모든 모듈이 활성되지
  않더라도 테스트가 가능하기 때문에 비교적 비용이 낮다. 또한 새로운 기능이 추가될 때마다 즉각적인
  테스트가 가능하기 때문에 유용하다. 
  
* JUnit5, AssertJ란?
  - JUnit은 단위 테스트 프레임워크이다. assert 메서드를 통해 테스트의 수행결과를 판결한다. JUnit5는
    자바 8버전부터 사용가능하며 JUnit Flatform, JUnit Jupiter, JUnit Vintage로 크게 3가지 하위 프로
    젝트로 구성되어 있다. JUnit Flatform은 JVM에서 돌아가는 테스트 프레임워크이다. 테스트를 발견하고
    테스트 계획을 생성하는 TestEngine 인터페이스를 가지고 있다. JUnit Jupiter는 JUnit5에서의 테스트
    코드 작성을 위한 새로운 프로그래밍 모델, 확장 모델이다. JUnit Vintage는 이전 버전인 JUnit3 혹은
    JUnit4 버전으로 작성한 테스트 코드를 실행할 수 있도록 해주는 테스트 엔진이다.
  - AssertJ는 테스트 코드 작성을 지원하는 라이브러리이다. assertThat(검증대상)으로 시작하여 메서드
    체이닝을 통해 검증 메서드를 연쇄적으로 사용한다. JUnit에서 제공하는 함수와 달리 메서드 체이닝을
    사용하기 때문에 가독성이 좋다.

* BDD란?
  BDD에 앞서 TDD에 대해 먼저 알아보자. TDD는 Test Driven Development의 약자로 테스트 중심적으로 개발
  하는 방법론이다. 코드 작성에 앞서 테스트 코드를 먼저 작성하고 테스트가 정상적으로 이루어질 때까지
  테스트를 반복하며 코드를 작성하는 것이다. BDD는 Behavior Driven Development의 약자로 TDD에서 파생된
  방법론이다. TDD와 달리 기획을 중점으로 테스트하는 것이다. 기획에서 사용자의 "행동"에 반응하여 작동할
  기능들을 테스트하는데 이 때 테스트를 TDD와 마찬가지로 테스트 코드를 통해 진행하기 때문에 TDD와 같아
  보일 수 있다. BDD는 시나리오를 검증하고 TDD는 해당 시나리오에 필요한 모듈들을 테스트한다고 생각하면
  편할 것이다. BDD는 TDD와 달리 시나리오를 검증하기에 비개발자들이 이해하기 쉼다. 때문에 비개발자와의
  협업 시 사용하기 좋다는 장점 또한 있다. 

* private method test
  private 함수는 본래 테스트가 불가능하다. 때문에 보통 private 함수를 호출하는 public 함수에 대해 테스
  트를 진행한다. 하지만 private 함수 자체에 테스트가 필요할 경우가 있다. 이 경우 Reflction을 사용하다.
  Reflection은 객체의 메타 데이터를 통해 객체를 동적으로 생성하는 것이다. 이를 통해 테스트하고자 하는
  private 함수를 가진 객체를 생성하고 접근을 가능하게 설정하여 함수를 테스트한다. 하지만 이 경우 테스트
  클래스가 private 함수를 알게 됨으로써 결합도가 높아지고 함수 이름, 파라미터, 객체 이름 등에 변경이
  생길 경우 테스트가 실패하게 되어 유지보수의 비용 또한 높아진다. 때문에 private 함수에 대한 테스트는
  최대한 지양하는 것이 옳다.

* @ParameterizedTest
  @ParameterizedTest는 하나의 테스트 함수에 여러 개의 파라미터에 대해 테스트 할 수 있게 한다. 하나의
  메서드에 관해 여러 개의 테스트를 진행해야 할 때 하나의 파라미터 만을 사용한다면 각 테스트마다 테스트
  코드를 하나씩 생성해야 한다. 이 경우 테스트 코드의 중복이 생기게 된다. 이때 @ParameterizedTest를 사
  용해 여러 개의 파라미터를 적용하면하나의 테스트 코드만으로도 여러 개의 테스트가 가능해진다.  

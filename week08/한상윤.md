# 8주차

## **HTTP 요청이 들어왔을 때 요청을 받고 응답하기 까지의 전 과정을 설명해주세요.**

- 필수 포함 단어(필터, 인터셉터, dispatcherServlet)

## **(선택) 혹시 위 질문에 대한 답을 찾다가 새로운 개념들을 발견하면 정리해볼까요??**

## HTTP란

1. 정의
HTTP란 프로토콜의 한 종류로써, 웹 브라우저와 웹 서버 사이의 통신 규약이다.  Hyper Text Transfer Protocol로 Hyper text(일반 text를 넘어서는 이미지, 링크등을 표현할 수 있는 text를 의미한다. 웹에서 말하는 Hyper text의 주된 내용은 Html 이다.)을 전송하기 위한 프로토콜이라고 볼 수 있다.
현재 웹 브라우저의 url을 눌러보면 사용되는 프로토콜을 https 인 것을 확인 할 수 있는 데, 이것은 http에서 보완이 강화된 프로토콜이라고 볼 수 있다. 
그리고 HTTP는 tcp 기반으로 만들어진 프로토콜이다.

※ tcp 기반이란 것

이것을 이해하기 위해선, OSI 7 Layer와 TCP/IP 4 Layer의 개념을 알아야 한다. 쉽게 얘기하면, 통신을 할 때, 하나의 프로토콜만을 사용해서 통신을 하지 않는 다. 구별되는 영역들의 여러개의 프로토콜들을 기반으로 통신이 되는 것이다. OSI 7 Layer는 통신을 하기 위한 계층이 7개가 존재한다는 뜻으로,  물리 계층 → 데이터 링크 계층 → 네트워크 계층 → 전송 계층 → 세션 계층 → 표현 계층 → 응용 계층으로 이루어져있다. 이것은 데이터 통신 과정을 나타내기 위한 개념적인  측면에서 사용되었다고 본다. 그에 비해 TCP/IP 4계층은 실제로 널리 사용되는 네트워크 프로토콜 스택을 설명한다. 

TCP/IP 4 계층은 네트워크 엑세스 → 인터넷 계층 → 전송 계층 → 응용 계층 으로 이루어져있다.
이 역순으로 요청이 처리가 된다. 그래서 맨 처음에 전송할 데이터를 만드는 부분은 응용 계층이다. 웹에서는 브라우저를 통해, HTTP 데이터를 생성하고 그거를 웹 서버에 보낸다. 이렇게 만들어진 데이터가 올바른 목적지로 가기 위해서 이 3가지 계층을 지나게 된다.
전송계층에서는 이 데이터를 보낼 도착지를 확인하고, 그 도착지로 보내는 작업을 한다. 그리고 그것을 OS가 하게 되는 데, 브라우저가 OS에게 전달하고, OS가 그것의 도착지 (여기서 도착지의 개념은 **포트넘버**를 사용한다.)에 맞는 곳에 전달하게 된다. 이 과정은 응용프로그램으로 데이터의 송-수신, 전송을 담당하기 때문에, 전송 계층이라고 한다. 그런데 포트넘버는 아파트로 비유하면, 몇 호의 의미를 갖는 되게 세부한 주소이다. 그렇기 때문에 어떤 아파트인지에 대한 정보도 필요하다. 그 정보를 덧붙이는 계층이 바로 인터넷 계층이다.
인터넷 계층은 수 많은 네트워크가 연결된 인터넷 사이에서의 특정 주소를 IP라고 하는 데, 이 IP주소를 보낼 데이터에 붙이는 작업을 한다. IP는 네트워크 상에서의 주소이기 때문에, 완전히 고유하지 않다. 그래서 물리적인 컴퓨터 위치를 구별해야한다. 그래서 그러한 작업을 하는 게 네트워크 엑세스이다.

 컴퓨터에는 고유한 주소를 표시하기 위한 장치인 NIC(Network Interface Controller)가 존재한다. 이것은 컴퓨터가 네트워크로 접속하기 위해 반드시 필요한 장치이다. 이 NIC 주소를 표현하는 프로토콜이 바로 이더넷 프로토콜이고, MAC주소를 사용한다.   MAC 주소는 그래서 각자 전세계적으로 고유한 주소를 가지고 있고, 이것을 통해 데이터가 도달해야하는 위치를 명확하게 알 수 있다. 이것은 데이터를 전달하기 전 마지막 단계라서 네트워크 엑세스 단계라고도 부른다. 

<참고문헌 : [https://yozm.wishket.com/magazine/detail/1956/](https://yozm.wishket.com/magazine/detail/1956/)>

정리를 하면, 응용계층은 응용 프로그램간에 통신을 다루는 프로토콜이 존재한다. HTTP나 FTP, SMTP등이 존재한다. 전송 계층은 포트넘버를 사용해서, 도착지를 설정하는 데, 이 때 사용되는 프로토콜은 TCP 혹은 UDP가 있다. ( TCP는 연결 지향적이고 데이터 전송에 신뢰성이 높고, UDP는 비연결성이고, 신속한 데이터 전송을 제공한다. TCP는 패킷을 검사하고 그것이 완벽해야 데이터를 받는 데, UDP는 그냥 패킷을 막 보내서 패킷이 끊어져도 일단 받는 다고 생각하면 된다.)  인터넷 계층은 IP주소를 사용해서, 지금까지의 데이터를 캡슐화하고, 네트워크 엑세스는 MAC 주소를 활용해서 데이터를 물리적인 네트워크 주소로 보낸다.
그래서 Http 방식은 전송계층의 프로토콜은 TCP이고, 인터넷계층은 IP를 사용해서 TCP/IP 기반인 것이다.

1. 통신 방식
클라이언트의 요청과 서버의 응답으로 이루어진다. 요청과 응답은 메타데이터가 포함된 헤더와 리소스의 데이터가 포함된 바디로 이루어져있다. 
- 요청
요청인 경우, 요청라인, 헤더, 본문이 3가지로 구성되어 있다.

1) 요청라인 (Http 메서드, Url)

**Http 메서드** : 요청의 동작을 나타내는 메서드를 의미한다.

- **Get** : 정보를 요청하기 위해서 사용된다. Reqeust_URL에 정보를 붙여서 요청한다.

- **Post** : 자신의 정보를 보낼 때 사용되는 데, Request_Body에 정보를 넣어서 보낸다. 
그리고 보낼 때 바디에는 JSON이나, XML 형태로 담아서 보낸다.

- **Put** : 정보를 업데이트하기 위해서 사용된다. Put은 멱등적인 메소드로, 멱등적이란 몇번의 연산을 해도, 결과값이 달라지지 않는 것을 의미한다. 즉 이것이 Post와 Put의 차이점인데, Post인 경우 새로운 리소스를 만들 때 사용되고, Put은 기존에 존재하는 리소스를 업데이트할 때 사용된다. 

- **Patch** : 이것도 정보를 업데이트 하기 위해서 사용된다. 하지만 이것은 멱등성을 가지고 있지 않다.  Put과의 차이는, Put은 수정할 때 모든 필드에 대해서 수정해야한다. 만약에 수정하지 않는 다면, 빠진 필드는 null이 된다. 하지만 Patch인 경우에는 일부분에 대한 수정이 가능하다.

{ “username” = “yoon”
”email” = “gkstkddbs99”
} 라는 원본 데이터가 있을 때, 
put{
”email” =”gkstkddbs”
} 
하면 결과가
{ “username” = null
 “email” = “gkstkddbs”
}
이 되고,
patch{
”email” =”gkstkddbs”
}을 하게 되면 결과가
{ “username” = “yoon”
 “email” = “gkstkddbs”
}이 된다.

- **Delete**: 서버가 가지고 있는 리소스를 삭제해달라고 하는 메서드이다.

- **Head** : Get과 유사하게 사용되지만, 서버의 응답 본문을 제외하고, 헤더 정보만을 요구하는 메서드이다. 즉 리소스의 메타 데이터를 확인하는 메서드이다.

-**Options** :  서버가 지원하는 HTTP 메서드의 목록이나 리소스에 대한 지원 옵션을 요청한다.

-**Trace** : 클라이언트의 요청을 그대로 반환한다. TRACE 요청을 보내면, 서버는 해당 요청의 헤더와 본문을 그대로 클라이언트에게 준다. 이것을 하는 이유는 디버깅이나 테스트 목적으로 사용된다.

******URL******
Url이란 Uniform Resource Identifier의 약자로써, 웹 서버가 리소스를 고유하게 식별할 수 있도록 한다. 
URL의 구조는 프로토콜://호스트 주소(IP주소):포트넘버/Path?쿼리로 이루어져있다.
Path는 서버안에 존재하는 폴더의 길이라고 생각하면 된다. 쿼리는 url에서 추가적인 데이터를 표현할 때 사용되는 데, “key”=”value” 형태로 나타나진다.

2) 헤더
헤더에는 필드가 존재하는 데, 키-값 쌍의 형태로 존재한다. 
요청에 대한 메타 데이터를 포함하고 있다.
헤더를 나타내는 키들이 정해져있다. 

신기한 헤더들
User-Agent : 현재 사용자가 어떤 클라이언트(운영체제, 브라우저)를 통해 요청을 보냈는 지 알 수 있다. 이것은 나중에 통계할 때 좋을 것 같다.
Cookie : 웹 서버가 클라이언트에 쿠키를 주었다면, 클라이언트가 요청을 보낼 때 쿠키의 정보를 이름- 값 형태로 전달한다. 
<참조할 때 [https://goddaehee.tistory.com/169](https://goddaehee.tistory.com/169)>

3) 본문(body)
Post나 Put, Patch 메서드의 요청일 경우에 사용된다. 요청에 필요한 데이터를 본문에 담아서 서버에게 전달한다.
- 응답
응답인 경우 상태라인, 헤더, 본문으로 이루어져 있다.

1) 상태 라인
상태 라인은 HTTP 프로토콜 버전을 나타낸다.
 상태라인에는 요청 처리 결과를 나타내는 응답 코드가 존재한다. 
상태 메시지는 사람이 결과에 대한 이해를 돕기 위한 짧은 정보 텍스트를 말한다.

※응답코드
응답코드는 크게 5개의 범주로 나뉠 수 있다.
1. 1xx : 서버가 현재 요청을 처리중이다라는 것을 나타낸다. 그리고 추가적인 요청이나 정보를 받기 기다리는 것을 의미한다.
2. 2xx : 요청이 성공적으로 처리된 것을 나타낸다.
3. 3xx : 리다이렉션에 대한 것을 의미한다. 리다이렉션은 원래 다른 페이지로 날리는 것을 의미한다. 이 응답코드는 클라이언트에게 다른 url로 이동하라는 것을 알려준다.
4. 4xx : 클라이언트쪽의 요청이 문제가 있거나, 요청한 리소스 소스를 찾을 수 없다는걸 나타낸다.
5. 5xx : 서버쪽에 문제가 있는 것을 나타낸다.

※실제 예시
**100** **Continue** : 클라이언트가 요청을 보낼 때 서버가 일부 요청을 받았고, 나머지 요청도 줘도 된다는 것을 의미한다.
**101 Switching Protocols:** 클라이언트한테 새로운 프로토콜로 요청해달라는 것을 의미한다.

**200 OK**: 클라이언트의 요청을 성공적으로 처리했다는 것을 의미한다.
**201 Created** : 클라이언트 요청으로 새로운 리소스가 성공적으로 만들어진 걸 의미한다.

**301 Moved Permanently**: 요청한 리소스가 영구적으로 다른 url에 이동했다는 걸 의미한다.
**302 Found**: 일시적으로 요청한 리소스가 다른 url로 이동했다는 걸 의미한다. 

**400 Bad Request**: 클라이언트 요청이 서버에서 이해할 수 없거나, 잘못된 구문으로 작성된 것을 의미한다. 
**404 Not Found**: 클라이언트가 요청한 리소스가 서버에 아예 존재하지 않는 걸 의미한다. 요청한 URL이 잘못되었거나, 실제로 아예 없는 상황에서 나타난다.

**500 Internal Server Error**: 서버에서 요청을 처리할 때 내부적인 오류가 발생했을 때 나타난다. (서버가 꺼져있어도 500을 준다)

2) 헤더
헤더에는 필드가 존재하는 데, 키-값 쌍의 형태로 존재한다. 
응답에 대한 메타 데이터를 포함하고 있다.

3) 본문
실제 응답 데이터가 포함된 부분이다.
HTML, JSON, 이미지, 파일등 다양한 형식의 데이터가 본문에 포함될 수 있다.
본문은 응답의 종류에 따라 내용이 달라진다.

## Servlet

Servlet이란, 동적 웹 페이지를 만들 때, 사용되는 자바 기반의 웹 어플리케이션 프로그래밍 기술이다. 
즉 클라이언트의 요청을 받고, 응답을 보내는 웹 서버를 자바로 만드는 기술이다.

⇒> 근데 더 찾아보니까, 브라우저와 소통하고 웹 서버가 따로 존재하고, 그 웹 서버와 상호작용 하는 애플리케이션을 Servlet이라고 하는 것 같다. 뭐가 맞는 지 질문. 
WAS와 Web Server의 차이로 알 수 있다.
Web Server는 정적인 컨텐츠(Html,jpeg,Css)를 제공하는 프로그램이다. 그리고 WAS는 Web Server와 Web Containner를 둘다 가지고 있는 서버를 의미한다. 그래서 현재 서블릿은 Web Containner 안에 존재하는 거기 때문에, 웹 서버와 상호작용하는 애플리케이션이라고 볼 수 있다.

서블릿을 자바로 구현된 CGI라고 말한다.

※CGI 
Common Gateway Interface의 약자로써, 서버와 애플리케이션 간에 데이터를 주고 받는 방식을 의미한다. 유저가 데이터를 웹 서버로 보내면, 웹 서버에서 그것을 처리하는 게 아니라, 웹 서버와 연결된 웹 애플리케이션에게 주고, 웹 애플리케이션이 DB에서 정보를 가져오고 받은 데이터를 가공해서 그 결과를 웹 서버에게 주는 방식을 의미한다. 
이것의 장점으로는 언어, 플랫 독립적이다. 매우 단순하다. 재사용할 수 있는 CGI 코드 라이브러리가 풍부하다. CGI가 웹 서버에서 실행될 때 안전하다. CGI는 가볍다.

{이렇게 될 수 있는 게 어쨌든 웹 서버와 분리되었기 때문에, 그것을 처리하는 로직을 자유롭게 짤 수 있어서 그런건가?}
단점으로는, 느리고, Http 요청마다 프로세스를 만들어야 해서 메모리를 많이 잡아 먹고, 페이 로드 사이에 데이터가 메모리에 캐시될 수 없다.

-특징

- 클라이언트로부터 HTTP 요청을 받아들인다. ( javax.servlet.http.HttpServlet 클래스를 상속받았기 때문이다.)
- 자바의 쓰레드를 이용해서 동작한다.
- 클라이언트에게 HTTP로 응답을 주는 데, 거기엔 응답의 상태 코드, 헤더, 본문을 설정하고, 그 본문에는 Html, Json, XML 형태로 줄 수 있다.
- 세션을 통해 관리할 수 있다. 세션을 사용한다면, 클라이언트의 상태를 유지하거나, 인증 인가를 구현할 수 있다.
- UDP보다 처리 속도가 느리다. ( TCP를 사용한다는 뜻)

-동작방식

1. 클라이언트 요청이 들어온다.
2. HttpServletRequest, HttpServletResponse 객체가 생성된다.
3. 사용자가 요청한 url이 어느 서블릿에 대한 요청인지를 web.xml가 찾는다.
4. 찾은 해당 서블릿의 service() 메서드가 호출되고, http 메서드 함수에 따라 doGet(), doPost() 메서드가 호출이 된다.
5. doGet()나 doPost() 메서드가 실행된 후, 동적 페이즈를 생성해서, HttpServletResponse객체에 응답을 전송한다.
6. HttpServletRequest, HttpServletResponse 객체가 소멸된다.

※ ****web.xml : 서블릿을 만들면, 그 서블릿과 url을 미리 매핑 시켜 놓아야 한다. 그래야 WAS에서 맵핑된 정보를 읽어서, 들어온 요청의 url에 따라서 해당 서블릿을 찾을 수 있다. 톰캣의 경우에는 server 디렉토리의 web.xml에 있다.

-서블릿 형식

```java
public class FirstServlet extends HttpServlet {
	@Override
    public void init() {
    ...
	}

    @Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp) {
    ...
    }

    @Override
    public void destroy() {
    ...
    }
}
```

-Servlet 컨테이너

- 정의
우리가 만든 여러가지 Servlet을 관리하는, Control해주는 부분이 바로 Servlet 컨테이너이다. 서블릿이 어떤 역할을 하는 제조법이라면, 서블릿 컨테이너는 그걸 가져와서 만들고 사용하고, 분해하는 놈이라고 생각하면 된다. 이것만이 아니라 웹서버와의 통신도 얘가 담당한다. 대표적인 Servlet 컨테이너의 예시는 Tomcat이다. ( Tomcat은 자바 서블렛을 구현할 수 있게 하고, 자바 웹 애플리케이션을 실행할 수 있다.)
- 역할
1. 웹 서버와의 통신 지원
원래 웹 서버와 통신을 하기 위해선 소켓을 만들고, listen, accpet 이런 메서드를 구현해야하지만, 서블릿 컨테이너는 이러한 기능을 API로 제공해서, 복잡한 통신 과정을 생략할 수 있게 한다.

2. 서블릿 생명 주기 관리
서블릿을 생성하고, 없애는 걸 관리한다. 밑에서 자세히!

3. 멀티쓰레드 지원 및 관리
매 요청이 들어올 때마다, 새로운 쓰레드를 만들어서 처리를 해야한다. 하지만 그 쓰레드의 처리 메서드가 실행되면 자동으로 쓰레드가 죽게 된다. 원래 이러한 쓰레드를 관리해야하지만, 서버가 그것을 운영해줘서 신경쓰지 않아도 된다.
4. 선언적인 보완 관리 
**나중에 더 찾아**

-Servlet 생명주기
클라이언트의 요청이 들어오면, 그 요청의 url을 분석해서  web.xml이 해당 서블렛을 찾는 다고 언급했다. 하지만 Servlet 컨테이너가 관리할 경우에 먼저 메모리에 해당 서블렛이 올라와 있는 지 확인하고, 없으면 init()메소드로 해당 서블렛을 최초로 메모리에 올린다. init()이 호출된 다음에는 service() 메서드가 호출이 되고, Get이냐 Post이냐에 따라 doGet() 혹 doPost() 메서드가 호출이 된다. 

몰론 그 doGet이냐 doPost의 매개변수로, 요청이 들어오자마자 만들어진 HttpServletReponse, HttpServletRequest 객체가 들어가진다.
그리고 컨테이너가 서블릿에게 종료 요청을 보내면, 그때 메모리에서 그 서블릿을 제거한다.

-JSP

Java Server Page의 약자이다. HTML 코드에 자바 코드를 넣어서, 동적 웹페이지를 생성하기 위한 기술이다. 서버측에서 HTML로 페이지를 만들고, 데이터에 따라 동적으로 페이지를 만들어서 반환해야한다. 그래서 JSP는 그 동적을 변하는 부분을 자바 코드를 삽입해서 가능하게 만드는 파일이다. JSP 파일 안에는 HTML 코드가 존재하고, <% %> 안에 자바 코드를 넣어서, 이 JSP가 서블릿 컨테이너에서 실행될 때, 자바 코드가 로직에 맞게 처리가 되고 그 값이 페이지에 포함되게 한다. 

html 페이지에 자바 코드를 넣어서, 동적인 페이지를 만드는 기술이라고 보면 된다.   

<참고 문헌 : [https://mangkyu.tistory.com/14](https://mangkyu.tistory.com/14) >

## Dispathcher 서블릿

- 나온 배경과 정의

이 Dispathcer 서블릿의 역할은 컨트롤러의 컨트롤러로 볼 수 있다.

이것이 없다면, 사용자에 요청에 대한 url과 서블릿(컨트롤러)을 web.xml에 일일히 다 매핑을 시켜놓아야 한다. 

그래서 우린 이 Dispathcher 서블릿을 사용함으로써, xml 의존도를 낮출 수 있게 되었다.
그래서 컨트롤러를 구현해두기만 하면, 디스패치 서블릿이 알아서 url과 매핑시켜줘서 굉장히 편리해졌다. 

이 서블릿은 Servlet 컨테이너안에 존재하고, 들어오는 모든 HTTP 요청, URL을 받는 다. 그래서 프론트 컨트롤러 역할을 수행한다고 말한다.

- DispatcherServlet 처리 흐름

![1](https://github.com/COW-edu/COW-Spring-2/assets/120346721/79deb4b1-c49f-4326-a0c7-1fc83d00cfc9)


HandlerMapping에 컨트롤러들의 정보가 있는 거지, 컨트롤러를 꺼내서 사용하는, 결정하는 것은 Dispatcher Servlet이다. 

적절한 Controller를 호출하고, 처리를 한다음에, 그 결과값을 DispatcherServlet이 바로 클라이언트에게 주는 것이 아니라, ViewResolver에게 전달한다. ViewResolver는 적절한 뷰를 찾는 다. 
그 View는 만들어진 틀, 혹은 JSP파일을 가져와서 거기에 결과 데이터를 결합해서 최종적인 응답(HTML, JSON, XML)을 반환한다.

※ Dispathcher Servlet 코드

스프링 MVC 구조에서 기본적으로 사용되는 서블릿이 Dispatcher Servlet이다. 거기서 사용되는 Dispathcher Servlet 코드를 자세히 뜯어보겠다.

1. doService()

기본적으로 서블릿이 호출되면, 무조건 doService() 함수가 호출이 된다. 그리고 그 아래에는 doDispatch() 메서드가 존재한다. 이 메서드는 위에 그림처럼  Dispath를 실행시키는 것이다.

1. 핸들러와 해당 핸들러를 받기 위한 어댑터 조회

클라이언트의 요청을 분석해서, 그걸 처리할 핸들러와, 그걸 받아서 사용할 어댑터는 조회한다.
( 이 단계에서 그러면 없으면 init()해서 만드는 건가>?)

1. 어댑터의 handle()메서드 호출

2번에서 찾은 핸들러 어댑터의 handle() 메서드를 호출해서, ModelAndView를 반환하고, processDispathchResult() 메서드를 호출한다.

1. processDispathchResult() 안에서 뷰의 render() 메서드를 호출

processDispathchResult() 안에서 뷰의 render() 메서드를 호출하고, 그 매개변수로 view Resolver가 있어서 적절한 뷰를 찾고, 그 뷰를 반환한다. 

※ 핸들러와 어댑터

[https://velog.io/@woply/spring-스프링-MVC의-전체-구조-이해하기](https://velog.io/@woply/spring-%EC%8A%A4%ED%94%84%EB%A7%81-MVC%EC%9D%98-%EC%A0%84%EC%B2%B4-%EA%B5%AC%EC%A1%B0-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0) 

{나중에 이거 다시 보면서, 추가 이해하기.}

![2](https://github.com/COW-edu/COW-Spring-2/assets/120346721/a8867f28-4c4f-4a6b-a30a-c599e501a6cc)

## Filter 와 Interceptor

위에 사진을 보면, Filter와 Interceptor가 Dispatcher Servlet 사이에 두고 존재하고 있다. 

- Filter

디스패치 서블릿에 들어오는 요청은 URL 형태로 들어온다. 그래서 이 필터는 URL에 관련된 거름망 역할을 한다. 필터는 “J2EE” 표준 스펙 기능으로 url 패턴에 맞는 요청에 대한 부가 작업을 처리할 수 있는 기능을 제공한다. 필터는 스프링 컨테이너 안에 존재하지 않는 다. 톰켓과 같은 웹 컨테이터에 의해 관리가 된다. 그렇기 때문에, 스프링과 무관하게, 전역적으로 처리해야하는 작업들을 수행한다. 

(웹 서버 프로그래밍과는 무관한 작업을 하는 것 같다.)

그래서 로깅, 문자 인코딩 변환, 보완 같은 작업을 한다. 

필터는 web.xml 파일이나 어노테이션을 사용해서 설정할 수 있다.

※메서드

1) init() : 필터 객체를 초기화하고, 서비스에 추가하는 메서드. 필터는 웹 컨테이너가 한번 init 메서드로 호출해서 필터 객체를 초기화한다. 그리고 다음에 사용될 땐, doFilter()를 통해 처리가 된다.

2) doFilter(): 모든 HTTP 요청이 디스패치 서블릿으로 전달되기 전에 실행되는 메서드이다. 이것의 파라미터는 FilterChain이 있는 데, FiterChain의 doFilter()를 통해 다음 대상에게 요청을 전달하게 된다. 

3) destory(): 필터 객체를 서비스에서 더이상 쓰지 않아서, 제거하는 메소드이다. 이는 웹 컨테이너가 한번만 호출하고, 이젠 doFilter()에 의해 처리가 되지 않는다.  

- Interceptor

Interceptor는 스프링 MVC에서 제공하는 기능으로 스프링 컨테이너 안에 존재한다.

필터는 클라이언트 요청을 처리하는 느낌이라면, Interceptor는 Dispathcer Servlet의 요청과 응답을 가공,처리하는 느낌이다.  

필터는 url 자체가 정상적인 지 확인하는 반면, 인터셉터는 클라이언트 요청 안에 있는 내용이 올바른 지 확인한다. 그래서 인증과 인가와 같은 작업을 한다. 

※메서드

1) preHandle() : 이 메서드는 컨트롤러를 호출하기 전에 실행된다. 그래서 컨트롤러 연결 전에 처리해야하는 작업이나, 요청 정보 가공을 하는 경우에 사용된다. 
또한, preHandle의 3번째 파라미터인 handler 파라미터는, 핸들러 매핑이 찾아서 주는 거다. 그래서 만약 핸들러가 없다면, 작업이 중단된다.

2) postHandle(): 이건 컨트롤러가 호출된 후에 실행이 된다. 이 메소드는 컨트롤러가 반환하는 ModelAndView 타입의 정보가 제공되는 데, 최근에는 Json 형태 데이터를 제공하는 RestAPI 기반 컨트롤러를 사용하면서 자주 안쓴다.

3) afterCompletion(): 이건 이름 그대로, 처리가 끝나고, 뷰에서 최종 결과를 생성도 끝난 다음에 실행되는 메소드이다. 이건 리소스를 반환하는 용도로 사용되고, 중간에 예외가 발생하더라고, 반드시 호출된다.

- 큰 차이점

필터는 HttpServletRequest나 HttpServletResponse에 대한 조작이 가능하다. 하지만 인터셉터는 그 객체들을 받아서 사용하기 때문에 조작은 불가능 하다. 하지만, 해당 객체 안에 있는 값을 조작할 수 있기 때문에, 비즈니스나, 요청, 응답의 내용물을 다룰 수 있다. (클라이언트에게 받은 JWT  토큰을 해석해서, 정보 얻기 등)

또 필터는 웹 애플리케이션 전체에 적용되지만, 인터셉터는 스프링 MVC 한에서만 동작한다. 

※J2EE

Java 2 Platform, Enterprise Edition의 약자로써 다양한 라이브러리와 API의 모음집.

서블릿(Servlet):
    웹 애플리케이션의 동적인 처리를 위한 자바 클래스

EJB(Enterprise JavaBeans):

JPA(Java Persistence API):
    객체-엔터티매핑을 위한 자바 표준 API입니다.
    데이터베이스와의 상호작용을 단순화할 수 있게 해준다.

JDBC(Java Database Connectivity):
    자바 프로그램과 데이터베이스 간의 연결을 제공하는 API.
    데이터베이스에 대한 쿼리 실행 및 결과 처리를 담당한다.

RMI

자바 버츄얼 머신끼리의 통신을 위한 기술

JNDI 

자바 기술로 만들어진 객체를 이름을 붙여서 찾을 수 있게 해주는 인터페이스를 제공한다.

포스트맨 url

[https://documenter.getpostman.com/view/27641064/2s9YXmY1Pe](https://documenter.getpostman.com/view/27641064/2s9YXmY1Pe)
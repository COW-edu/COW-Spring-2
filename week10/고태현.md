# [10WEEK] 10주차 학습 PR

## DB Indexing 이란?

---

> 데이터베이스분야에 있어서 테이블에 대한 동작 속도를 높여주는 자료구조를 일컫는다.
>

### 요약

1. 테이블에 대한 검색의 속도를 높여주는 자료구조
2. 색인이고 메모리 영역의 일종의 목차를 생성하는 개념
3. 따라서 이런 목차를 이용하여 검색 범위를 줄여 속도를 높일 수 있음

- 인덱스 종류
    - B-tree Index
    - Bitmap Index
    - IOT Index
    - Clustered Index

- 동작방법
    - 해당 테이블을 생성ㅎ시 생성하고 싶은 인덱스 컬럼 지정
    - 생성 후 인뎃스 조회 시, where 절이 포함된 쿼리로 조회
    - 인덱스로 저장된 key-value값을 참조해서 결과 출력

- 특징
    - index를 사용하면 검색 속도의 향상효과
    - 시스템 부하를 다운, 시스템 전체 성능향상에 기여
    - but, index를 위한 추고 공간 필요
    - 데이터가 많이 있다면 생성에 많은 시간 소요
    - insert, update, delete가 자주 발생시 성능이 하락

### clustering index

: 페이지를 알고 있어서 바로 해당 페이지를 펼치는 것과 같음

- 방법
    - 데이블의 데이터를 지정된 컬럼에 대해 물리적으로 데이터를 재배열
    - 데이터가 테이블에 삽입되는 순서에 상관없이 index로 생성되어 있는 칼럼을 기준으로 정렬
    - index page를 key-value와 page-number로 구성
    - 데이터의 키값으로 페이지 번호를 검색하여 찾음
    - 루트 페이지와 리프 페이지로 구성
        - 리프 페이지는 데이터 그 자체
    - 물리적으로 정렬되어 있어 검색 속도가 빠르지만 입력/수정/삭제 속도는 느리다

### Secondary Index

: 중복항목을 포함할 수 있는 인덱스, 다른 인덱스를 돕는 보조 인덱스

- 특징
    - 데이터 블록에서 행이 실제로 구서오디는 방식에 영향일 미치지 않음
    - 여러개의 인덱스를 가질 수 있음

## DB Relationship

---

> 엔티티와 엔티티 사이의 관계, 즉 관리하고자 하는 업무 영역내의 특정한 두 개의 엔티티 사이에 존재하는 많은 관게 중 특별히 관리하고자 하는 직접적인 관계를 의미
>

- 왜래키
    - 관계는 외래키로 구현되어 참조 무결성으로 데이터 정합성 유지의 역할을 함

1. 1:1 관계
    1. 어느 쪽 당사자의 입장에서 상대를 보더라도 반드시 단 하나씩과 관게를 가지는 것
    2. 특징
        1. 현시렝서 매우 드물게 나타나는 형태
        2. 업무의 흐름에 다라 데이터가 설계된 형태에서 많이 나타남
        3. 엔티티 수직 분할시에 많이 나타남
2. 1:m 관계
    1. 가장 흔하게 나타나는 매우 일반적인 형태. 마치 부모와 자식과의 관계처럼 계층적인 구조
    2. 특징
        1. 가장 흔하게 나타나는 관계 형태
        2. 참조할 정보는 나에게 반드시 하나만 존재해야함
3. n:m  관계
    1. 말 그대로 다대다 관계이다
    2. 특징
        1. 관계를 가진 양쪽 당사자 모두에서 1:m 관계가 존재할 때 나타나는 모습
        2. 선택 사양은 양쪽 모두가 선택적인 것이 기본형

## JPA 엔티티의 생명주기

---

> ORM 기술 표준으로 사용되는 인터페이스의 모음. 실제적으로 구현된것이 아니라 구현된 클래스와 매핑을 해주기 위해 사용되는 프레임 워크
>

- JPA의 내부 동작
    - EntityManagerFactory가 요청마다 EntityManger를 생성해주고, EntityManger는 커넥션 풀을 통해 디비에 접근

- 비영속(new/transient)
    - 순수한 객체 상태이며, 영속성 컨텍스트와 관련이 없는 상태

    ```java
    Member member = new Member();
    ```


- 영속(managed)
    - EntityManager를 통해 엔티티를 영속성 컨텍스트에 저장되어 영속성 컨텍스트가 관리하는 상태

    ```java
    em.persist(member); // 객체 저장
    ```

- 준영속(detached)
    - 영속성 컨텍스트에 저장되었다가 분리된상태

    ```java
    em.detach(member); // 특정 엔티티를 분리
    
    em.close(); // 영속성 컨텍스트 닫기
    em.clear(); // 영속성 컨텍스트 초기화
    ```


- 삭제
    - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한 상태

    ```java
    em.remove(member);
    ```


## @id, @GeneratedValue

---

> id는 Primary Key와 같은 의미를 가지며 어노테이션으로 표기
>
- @id

    ```java
    @Id
    @Column
    prvate String code;
    ```

- @GeneratedValue
    - 구분이 가능한 유일한 값을 가지고 있어야 하고 데이터 경합으로 인해 발생되는 데드락 같은 현상을 방지 하기 위해 Long을 사용
        - 데드락 : 동일한 시점에 요청이 유입 되었을 대 데이터베이스는 테이블 혹은 레코드 lock을 걸어 데이터가 변경되지 않도록 막아 놓고 다른 작업을 함

    ```java
    @Id
    @SequenceGenerator(name="seq", sequeneceName="jpa_sequence")
    @GeneratedValue(strategy=GenerationType.SEQUENCE, generator="seq")
    private Long id;
    ```
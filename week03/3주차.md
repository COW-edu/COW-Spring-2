# [카우 3주차]

---

**3주차 학습 PR**

학습 PR 역시 로또 리팩토링에 도움이 되는 내용들로 구성되어 있습니다. 해당 개념들을 학습한 뒤, 본인의 로또 코드에 적용까지 해 보신다면..? 비로소 본인 것이 됩니다 ㅎㅎ

아래 `*` 은 여러분들의 학습을 위한 **최소한의** 가이드라인입니다. 꼭 깊이있는 학습 후에 꼼꼼하게 기록해주세요💯

## **일급 컬렉션이란?**

- 일급 컬렉션이란?
  - Java에서 일급 컬렉션(First-Class Collection)은 다른 객체와 동등한 지위를 갖는 컬렉션 객체
  - 특징
    - 컬렉션 객체는 변수나 매개변수에 할당할 수 있다.
    - 컬렉션 객체는 다른 객체와 동등한 지위를 가진다.
    - 컬렉션 객체는 반환값으로 사용할 수 있다.
    - 컬렉션 객체는 필요한 경우 메서드에서 생성할 수 있다.

    <aside>
    💡 간단하게 말하면 **Collection을 Wrapping 하면서, 그 외 다른 멤버 변수가 없는 상태**를 **일급 컬렉션**이라 한다!

    </aside>

  - 일급 컬렉션을 사용하지 않은 코드

      ```jsx
      public class Student {
          private List<String> subjects;
      
          public Student(List<String> subjects) {
              this.subjects = subjects;
          }
      
          public List<String> getSubjects() {
              return subjects;
          }
      }
      ```

    위 코드 중 Student 클래스에서 List<String> 타입의 subjects를 직접 다루고 있다. 이 경우 Student 클래스는 List 타입에 의존성을 갖게 되며, List의 구현이 변경될 경우 Student 클래스도 함께 변경되어야 하는 문제점을 가지고 있다.


  - 일급 컬렉션을 사용한 코드

      ```jsx
      public class Student {
          private Subjects subjects;
      
          public Student(Subjects subjects) {
              this.subjects = subjects;
          }
      
          public Subjects getSubjects() {
              return subjects;
          }
      }
      
      public class Subjects {
          private List<String> subjects;
      
          public Subjects(List<String> subjects) {
              this.subjects = subjects;
          }
      
          public void addSubject(String subject) {
              subjects.add(subject);
          }
      
          public List<String> getSubjects() {
              return new ArrayList<>(subjects);
          }
      }
      ```

    위 코드에서는 Student 클래스에서 Subjects 클래스를 사용하도록 변경되었다. Subjects 클래스는 List<String>타입의 Subjects를 감싸고 있으며, Subject 객체를 추가하거나, 모든 Subject 객체를 가져올 수 있도록 메서드를 제공한다.
  -
    이렇게 함으로써, Student 클래스는 Subjects 클래스랑만 의존성을 갖게 되고 이전에 지녔던 문제점인 List타입에 대한 의존성을 제거할 수 있다.

- 일급 컬렉션은 왜 사용하는가? 어떤 장점이 있는지?

  1.  가독성과 유지보수성이 향상된다.

  일급컬렉션을 사용하면 해당 컬렉션을 사용하는 클래스에서 해당 컬렉션의 역할과 의미를 바로 파악할 수 있고, 유지보수성이 향상된다.

  1. 유효성 검증이 용이해진다.

     일급 컬렉션을 사용하면 해당 컬렉션의 내부 구현을 캡슐화할 수 있기 때문에 유효성 검증 코드를 해당 컬렉션 클래스 내부에 구현하여 컬렉션의 사용자들이 해당 유효성 검증 로직을 호출하는 번거로움을 줄일 수 있다.

  2. 불변성을 보장할 수 있다.

     일급 컬렉션을 사용하면 해당 컬렉션을 불변(immutable)으로 만들어서 변경을 방지할 수 있다.

- 불변 객체..방어적 복사도 함께 찾아보시면 좋을 것 같아요!
- [https://tecoble.techcourse.co.kr/post/2021-04-26-defensive-copy-vs-unmodifiable/](https://tecoble.techcourse.co.kr/post/2021-04-26-defensive-copy-vs-unmodifiable/)

## **MVC 패턴이란?**

- MVC는 왜 사용하는지?
  - Intro
    - 스프링 프레임워크의 모듈 중에는 웹 계층을 담당하는 몇 가지 모듈이 있다. 웹 계층에 서블릿(Servlet) API를 기반으로 클라이언트의 요청을 처리하는 모듈이 있는데 이를 **스프링 웹 MVC** 라고 한다.
      - 서블릿(Servlet)이란?
        - 클라이언트의 요청을 처리하도록 특정 규약에 맞춰 Java 코드로 작성하는 클래스 파일이다.
        - **아파치 톰캣(Apache Tomcat)**은 이러한 서블릿들이 웹 애플리케이션으로 실행할 수 있도록 해주는 서블릿 컨테이너(Servlet Container) 중 하나이다.
        - Spring MVC 내부에서는 서블릿을 기반으로 웹 애플리케이션을 동작하며, 스프링 부트는 기본적으로 아파치 톰캣이 내장되어 있다.
  - MVC란?

    MVC 패턴은 애플리케이션을 개발할 때 사용하는 디자인 패턴이다.

    애플리케이션의 개발 영역을 MVC(Model, View, Controller)로 구분하여 각 역할에 맞게 코드를 작성하는 개발 방식이다.

    MVC 패턴을 도입하면서 UI 영역과 도메인(비즈니스 로직) 영역으로 구분되어 서로에게 영향을 주지 않으면서 개발과 유지보수가 가능해지게 되었다.

    ![[출처: 인프런 김영한 강의]](%5B%E1%84%8F%E1%85%A1%E1%84%8B%E1%85%AE%203%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%2013426a9837e040c1bb5d8e3db912cf43/Untitled.png)

    [출처: 인프런 김영한 강의]

    - Model(모델)

      > 데이터(data) 가공을 책임지는 컴포넌트(component)
      >

      모델은 어플리케이션의 정보, 데이터를 나타냅니다. 데이타베이스, 초기화 된 상수나 값, 변수 등을 뜻합니다. 비즈니스 로직을 처리한 후 모델의 변경 사항을 컨트롤러와 뷰에 전달합니다.

      모델은 다음과 같은 규칙을 가지고 있습니다.

      - 사용자가 편집하길 원하는 모든 데이터를 가지고 있어야 합니다.
      - 뷰나 컨트롤러에 대해서 어떤 정보도 알지 말아야 합니다.
      - 변경이 일어나면, 변경 통지에 대한 처리 방법을 구현해야만 합니다.

    - View(뷰)

      > *사용자에게 보여지는 부분, 즉 유저 인터페이스(User interface)*
      >

      MVC 패턴은 여러 개의 뷰가 존재할 수 있으며, Model에게  데이터를 전달받는다.

      View는 받은 데이터를 화면에 표시해주는 역할을 가지고 있다. 모델에게 전달받은 데이터를 별도로 저장하지 않아야 한다. 사용자가 화면에 표시된 내용을 변경하게 되면 모델에게 전달하여 모델을 변경해야 합니다.

      뷰는 다음과 같은 규칙을 가지고 있습니다.

      - 모델이 가지고 있는 정보를 따로 저장해서는 안됩니다.
      - 모델이나 컨트롤러와 같이 다른 구성 요소들을 몰라야 됩니다.
      - 변경이 일어나면 변경통지에 대한 처리방법을 구현해야만 합니다.

      View는 Model을 이용하여 웹 브라우저와 같은 애플리케이션의 화면에 보이는 리소스(Resource)를 제공하는 역할을 한다.

      스프링 MVC에서 “View”는 사용자에게 표시되는 UI부분이다. 이는 데이터를 사용자에게 시각적으로 제공하도록 설계된 컴포넌트로, 일반적으로 HTML 형식으로 브라우저에 표시된다.

      그러나 “View”는 HTML만 한정되는 것은 아니며, JSON, XML 등 다른 형식으로도 데이터를 제공할 수 있다.

    - Controller(컨트롤러)

      > 모델과 뷰 사이를 이어주는 브릿지(bridge) 역할
      >

      모델이나 뷰는 서로의 존재를 모르고 있다. 변경 사항을 외부로 알리고 수신하는 방법만 있는데, 컨트롤러는 이를 중재하기 위한 컴포넌트다.

      모델과 뷰에 대해 알고 있으며, 모델이나 뷰로부터 변경 내용을 통지 받으면 이를 각 구성 요소에게 통지한다. 사용자가 어플리케이션을 조작하여 발생하는 변경 이벤트들을 처리하는 역할을 수행한다.

      컨트롤러는 다음과 같은 규칙을 가지고 있다.

      - 모델이나 뷰에 대해서 알고 있어야 한다.
      - 모델이나 뷰의 변경을 모니터링 해야 한다.

- MVC 패턴은 왜 등장했는가? 등장 배경?
  - 초기

    MVC 패턴을 적용하지 않고 서블릿만을 사용하여 상품 등록 뷰를 클라이언트에게 전달하기 위해서는 Response Body에 직접 HTML를 작성하여 응답해야 한다.

    HTML을 직접 개발자가 작성하면 생산성이 매우 떨어진다. 이로인해 HTML과 유사한 JSP가 나타난다.

  - JSP의 등장

    동적인 결과를 나타내기위해 HTML의 필요한 곳에 자바 코드를 작성하려는 시도가 있었고 그 결과 **JSP**가 탄생하였다. JSP를 사용하면 손쉽게 HTML을 작성할 수 있고 필요에 따라 자바 코드를 작성하여 클라이언트의 동적인 요청을 처리할 수 있다.

    JSP에 자바 코드를 작성하면 HTML 형식의 데이터를 손쉽게 작성할 수 있고, 서블릿은 단순히 요청이 들어오면 해당 서블릿에 렌더링만 해주면된다. 서블릿만 사용했을 때보다는 많이 발전했지만 문제는 여전히 존재한다.

    JSP에 너무 많은 책임이 부여된다. JSP에는 비즈니스 로직과 뷰에 대한 책임이 혼재한다. 비즈니스 로직을 수정 했을 때, 뷰에 대한 수정이 필요할 때 모두 JSP 코드를 수정해야한다. 그리고 결정적으로

    **비즈니스 로직과 뷰는 변경의 라이프 사이클이 다르다.**

    즉 비즈니스 로직의 변경 시기와 뷰의 변경 시기가 서로 다르다는 것이다. 보통 변경의 라이프 사이클이 다를 경우 역할을 분리해주는 것이 좋다.

  - MVC 패턴의 등장

    MVC 패턴은 이전에 JSP나 서블릿으로만 처리했던 과정을 모델-뷰-컨트롤러로 역할을 나누는 것을 의미한다.


## **Java의 Stream이란?**

- Stream의 특징? 장점?
  - 기존 루프문 처리의 문제점

    기존 Java에서 컬렉션 데이터를 처리할때는 for, foreach 루프문을 사용하면서 컬렉션 내의 요소들을 하나씩 다루었다. 간단한 처리나 컬렉션의 크기가 작으면 큰 문제가 아니지만 복잡한 처리가 필요하거나 컬렉션의 크기가 커지면 루프문의 사용은 성능저하를 일으키게 되었다.

  - 스트림의 등장

    스트림은 Java8에서 추가된 기능으로 컬렉션 데이터를 선언형으로 쉽게 처리할수 있다. 복잡한 루프문을 사용하지 않아도 되며 루프문을 중첩해서 사용해야 되는 최악의 경우도 더 이상 없어졌다.

  - 병렬 처리

    **외부 반복자(`external iterator`)**란 **개발자가 코드로 직접 컬렉션의 요소를 반복해서 가져오는 코드 패턴**이다. index를 이용하는 for문, 그리고 Iterator를 이용하는 while문은 모두 외부 반복자를 이용하는 것이다.

    반대로 **내부 반복자(iternal iterator)**란 **컬렉션 내부에서 요소들을 반복시키고, 개발자는 요소 당 처리해야 할 코드만 제공하는 코드 패턴**을 말한다.

    ![Untitled](%5B%E1%84%8F%E1%85%A1%E1%84%8B%E1%85%AE%203%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%2013426a9837e040c1bb5d8e3db912cf43/Untitled%201.png)

    - 내부 반복자를 사용했을 때의 이점

      내부 반복자를 사용하면 컬렉션 내부에서 어떻게 요소를 반복시킬 것인가는 컬렉션에게 맡겨두고, **개발자는 요소 처리 코드에만 집중할 수 있게 된다.** 내부 반복자는 요소들의 반복 순서를 변경하거나, 멀티 코어 CPU를 최대한 활용하기 위해 요소들을 분배시켜 병렬 작업을 할 수 있게 도와주기 때문에 **하나씩 처리하는 순차적 외부 반복자보다는 효율적으로 요소를 반복시킬 수 있다.**


        **Iterator**는 **컬렉션의 요소를 가져오는 것에서부터 처리하는 것까지 모두 개발자가 작성**해야 하지만,**스트림**은 람다식으로 요소 처리 내용만 전달할 뿐, **반복은 컬렉션 내부에서 일어난다.**
        
        스트림을 이용하면 **코드도 간결**해지지만, 무엇보다도 **요소의 병렬 처리가 컬렉션 내부에서 처리**된다는 효과까지 있다.
        
        <aside>
        💡 병렬처리란, **한 가지 작업을 서브 작업으로 나누고, 서브 작업들을 분리된 스레드에서 병렬적으로 처리하는 것**을 말한다.
        
        </aside>
        
    - 작업 분류
        - 중간 연산
            - 연산결과가 스트림을 반환하기 때문에 스트림에 연속해서 중간 연산을 할  수 있다. (0 ~ n번)
        - 최종 연산
            - 연산 결과가 스트림이 아닌 연산으로, 스트림의 요소를 소모하기 때문에 마지막에 단 한번만 사용이 가능하다. (0~1번)
        
        ```jsx
        stream.distinct().limit(5).sorted().forEach(System.out::println);
        // distinct(), limit(), sorted() -> 중간 연산
        // 마지막 스트림을 소모하여 각 스트림의 요소를 출력하는 forEach -> 최종 연산
        ```
        
    - lazy Evaluation (지연된 연산)
        - 스트림에서 연산을 할때 한 가지 중요한 점은, 최종 연산이 수행되기 전까지는 중간 연산이 수행 되지 않는다는 점이다.
        - 위 코드에서 distinct()나 sorted()같은 중간 연산을 호출한다고 해도 즉각적인 연산이 시행되는 것이 아니다. 중간 연산을 호출하는 것은 단지 어떤 작업이 수행되어야 하는지를 지정해주는 것일 뿐이다.
        - **최종 연산이 수행 될때야 비로소 스트림의 요소들이 중간 연산이 수행된다.**
        
    - 내부 반복 방식
        - 외부 반복
            - 사용자가 직접 요소를 반복
        - 내부 반복
            - 스트림은 반복을 알아서 처리하고 결과 스트림값을 어딘가에 저장
            - 장점: 작업을 투명하게 병렬적으로 처리하거나 최적화된 다양한 순서로 처리가 가능하다.
    - for문과의 차이점?
- 중간 연산 메서드
  - ****filter() / distinct()****
    - filter()
      - Stream에서 조건에 맞는 데이터만을 정제하여 더 작은 컬렉션을 만드는 데 사용한다. 매개 값으로 조건이 주어지며, 참이 되는 요소만을 필터링한다.
    - distinct()
      - Stream 요소들의 중복된 데이터를 제거하기 위해 사용한다.
  - ****map() / flatMap()****
    - map()
      - 기존의 Stream 요소들을 대체하는 요소로 구성된 새로운 Stream을 형성하는 연산이다. 저장된 값을 특정한 형태로 변환하는 데 주로 사용된다.
    - flatMap()
      - 여러 개의 요소들로 구성된 새로운 스트림을 반환한다.
  - sorted()
    - Stream의 요소들을 정렬하기 위해 사용한다. sorted() 메서드는 파라미터로 Comparator를 넘길 수 있다.

      만약, 파라미터의 인자 없이 호출할 경우에는 오름차순 정렬을 한다.

      내림차순 정렬을 하기 위해서는 Comparator의 `reverseOrder(`) 메서드를 이용한다.

  - ****limit()****
    - 스트림에서 입력 값의 숫자만큼 요소들을 가져와 새로운 스트림을 생성한다.
  - ****peek()****
    - 요소를 하나씩 돌면서 출력하는 기능이다.
    - 중간 연산이므로 하나의 스트림에 여러 번 사용이 가능하다.
- 최종 연산 메서드
  - ****forEach()****
    - 요소를 하나씩 돌면서 출력하는 기능이다.
    - 스트림의 요소를 소모하기 때문에 한 번만 호출할 수 있다.
  - match()
    1. allMatch() : 모든 요소들이 매개 값으로 주어진 Predicate의 조건 검사
    2. anyMatch() : 최소한 한 개의 요소가 매개 값으로 주어진 Predicate의 조건 검사
    3. noneMatch() : 모든 요소들이 매개 값으로 주어진 Predicate의 만족하지 않는 조건 검사
  - ****sum(), count(), average(), max(), min()****
    - 집계에 대한 메서드

## **제네릭이란?**

**클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법**을 의미한다.

객체별로 다른 타입의 자료가 저장될 수 있도록 한다.

```jsx
ArrayList<String> list = new ArrayList<>();
// 꺽쇠 괄호가 제네릭!

```

괄호 안에는 타입명을 기재한다. 그러면 위 리스트 클래스 자료형의 타입은 String 타입으로 지정되어 문자열 데이터만 리스트에 적재할 수 있게 된다.

## **Optional이란?**

- NullPointerException(NPE)를 방지할 수 있도록 도와준다.
- **Optional<T>는 NULL이 올 수 있는 값을 감싸는 Wrapper 클래스로, NPE가 발생하지 않도록 도와준다.**
- Optional 클래스는 아래 예제처럼 value에 값을 저장하기 때문에 NULL이더라도 바로 NPE가 발생하지 않으며, 각종 메서드를 제공한다.

```jsx
public final class Optional<T> {

  private final T value;
...

}
```

- 하지만, Optional은 데이터를 Wrapping하고 다시 풀고, NULL일 경우에는 대체 함수를 호출하는 등의 오버헤드가 있으므로 성능이 저하될 수 있다.
- 그래서 메서드의 반환 값이 절대 NULL이 아니라면 Optional을 사용하지 않는 것이 성능 저하가 적다.

<aside>
💡 즉, **Optional은 메서드의 결과가 NULL이 될 수 있으며, 클라이언트가 이 상황을 처리해야 할 때 사용하는 것이 효율적**이다.

</aside>

## **References**

- [일급 컬렉션(First-Class Collection)이란? (tistory.com)](https://dkswnkk.tistory.com/696)
- [[Java] 스트림과 병렬 처리 ① (velog.io)](https://velog.io/@mmy789/Java-%EC%8A%A4%ED%8A%B8%EB%A6%BC%EA%B3%BC-%EB%B3%91%EB%A0%AC-%EC%B2%98%EB%A6%AC-1)
- [[Java] Optional이란? 개념과 사용법 - 1 (tistory.com)](https://frtt0608.tistory.com/152)
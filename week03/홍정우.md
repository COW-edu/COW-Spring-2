# Cow - Week3

## 일급 컬렉션

- 일급 컬렉션(First-class Collection)은 프로그래밍에서 컬렉션을 일급 객체(First-class Object)처럼 다루는 개념입니다.
- 콜렉션을 포함한 클래스는 반드시 다른 멤버 변수가 없어야 한다.

**일급 컬렉션을 사용하는 이유와 장점**

1. **불변성(Immutability)**: 일급 컬렉션은 불변 객체로 다룰 수 있다. 이것은 컬렉션을 변경할 수 없다는 것을 의미하며, 데이터의 무결성을 보장하고 다중 스레드 환경에서의 문제를 방지하는데 도움이 된다.
    1. final과의 차이점은 final은 불변을 만들어주는 것이 아니라, 재할당만 금지인 것으로 값 변경이 가능하다.
2. **함수 조합성(Function Composition)**: 일급 컬렉션을 사용하면 함수를 조합할 때 더 쉽게 데이터를 다룰 수 있다.
3. **상태와 행위를 한 곳에서 관리 :** 값과 로직이 함께 존재한다. 
4. **가독성과 유지 보수성**: 일급 컬렉션을 사용하면 코드의 가독성을 높일 수 있다. 데이터 구조에 의미 있는 이름을 부여하고 이를 활용하여 코드를 작성하는 것이 가능하며, 이는 코드의 유지 보수를 쉽게 만들어 준다.
5. **에러 감소**: 일급 컬렉션을 사용하면 데이터를 처리하는 과정에서 발생하는 에러를 줄일 수 있다. 불변성과 유형 안정성(Type Safety)을 통해 코드를 안정적으로 유지할 수 있다.

불변 객체(Immutable Object)와 방어적 복사(Defensive Copy)는 일급 컬렉션과 관련이 있다. 불변 객체는 객체의 상태를 변경할 수 없게 만드는 개념으로, 데이터의 불변성을 보장하기 위해 사용된다. 방어적 복사는 불변 객체를 활용하여 다른 객체로부터 데이터를 보호하고 복사본을 제공하는 기술이다. 이는 데이터 무결성을 유지하고 예기치 않은 부작용을 방지하는 데 도움이 된다. 이러한 개념은 일급 컬렉션과 함께 사용될 때 코드의 안정성과 신뢰성을 높일 수 있는 장점이 있다.

****예제****

```java
Map<String, String> map = new HashMap<>();
map.put("1", "A");
map.put("2", "B");
map.put("3", "C");
```

위의 코드를 아래처럼 Wrapping하는 것

```java
public class GameRanking {

    private Map<String, String> ranks;

    public GameRanking(Map<String, String> ranks) {
        this.ranks = ranks;
    }
}
```

## MVC

****************MVC 패턴이란?****************

- MVC(Mode-View-Controller) 패턴은 소프트웨어 개발에서 사용되는 소프트웨어 아키텍처 패턴 중 하나로, 애플리케이션의 구성 요소를 세 가지 주요 역할로 분리하여 설계하는 방법.
- MVC 패턴을 활용함으로써 애플리케이션의 관심사를 분리하고 모듈화하여 유지 보수와 확장성을 개선할 수 있다.

**MVC 패턴의 3가지 요소**

1. **모델(Model)**: 모델은 애플리케이션의 데이터와 비즈니스 로직을 관리한다. 데이터의 상태를 저장하고 조작하며, 데이터 변경을 처리하고 필요한 정보를 제공한다.
2. **뷰(View)**: 뷰는 데이터를 시각적으로 표현하는 부분. 사용자 인터페이스(UI)를 담당하며, 모델의 데이터를 표시하고 사용자와 상호 작용하는 방법을 정의한다.
3. **컨트롤러(Controller)**: 컨트롤러는 사용자 입력을 처리하고 모델과 뷰 간의 상호 작용을 조정한다. 사용자의 요청을 받아 모델을 업데이트하고, 변경된 데이터를 뷰에 반영하는 역할을 한다.

**MVC 패턴 사용 이유는?**

1. **관심사 분리(Separation of Concerns)**: MVC는 애플리케이션의 다양한 측면(데이터 관리, UI 표현, 사용자 입력 처리)을 서로 분리하여 관리할 수 있게 하는 장점이 있다. 이로써 각 구성 요소를 독립적으로 개발하고 유지 보수할 수 있는 것이다.
2. **재사용성과 모듈화**: 각각의 MVC 구성 요소는 독립적으로 재사용할 수 있는 장점이 있다. 모델, 뷰, 컨트롤러를 다른 프로젝트에서도 활용할 수 있어 개발 생산성을 향상시킬 수 있다.
3. **유지 보수와 확장성**: 애플리케이션의 변경 사항을 더 쉽게 관리할 수 있다. 애플리케이션의 변화가 있을 때 다른 구성 요소에 영향을 주지 않고 해당 변경을 수행할 수 있게 된다.

**************MVC 패턴의 등장 배경**************

- 예전에는 자바 JSP와  서블릿만을 이용하여 웹 서비스를 개발하였다. 하지만 JSP의 경우 간단한 코드임에도 자바 코드와 HTML 코드가 복잡하게 얽혀 있어 가독성이 떨어질 뿐만 아니라 변경 생명 주기가 서로 다른 요소들이 결합(뷰 + 비즈니스 로직)되어 있다는 큰 문제가 있어 UI가 변경되어야 하는 시점에 비즈니스 로직도 함께 변경되어야 한다는 불편함이 있었다. 이러한 이유들을 타파하고자 등장하게 된 것이 MVC 패턴이다.
- 즉, 관심사의 분리를 통하여 애플리케이션의 다양한 측면을 서로 분리하여 관리하기 위하여 MVC 패턴이 등장한 것.

## Java의 Stream이란?

**Stream**

- 자바 8에서 추가한 스트림(*Streams*)은 람다를 활용할 수 있는 기술 중 하나이다.
    - 람다란? : 람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이라고 할 수 있다. 람다 표현식에는 이름은 없지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트는 가질 수 있다.

Stream의 특징 및 장점

- 병렬 처리
    - Stream을 사용하면 데이터를 병렬로 처리할 수 있다. **`parallel()`** 메서드를 사용하여 스트림을 병렬 스트림으로 변환하고, 멀티코어 프로세서를 활용하여 빠른 처리가 가능하다.
- 작업 분류
    - Stream 연산은 파이프라인 방식으로 연결할 수 있다. 이것은 한 번에 하나의 요소만 처리하는 대신 여러 연산을 연결하여 데이터를 처리하는 것을 의미한다.
- lazy Evaluatuin
    - Stream 연산은 지연 평가 방식으로 동작한다. 이것은 연산이 실제로 수행되기 전까지는 데이터를 읽거나 처리하지 않는다는 것을 의미한다. 이를 통해 필요한 연산만 수행할 수 있어 불필요한 연산을 피할 수 있다는 장점이 있다.
- 내부 방복 방식
    - Stream은 내부 반복을 사용하여 데이터를 처리한다. 이는 내가 명시적으로 루프를 작성하지 않아도 되고, 코드가 간결해지며 더 가독성이 높아지게 된다.
- for문과의 차이점
    - **`for`**문은 명시적으로 데이터 컬렉션을 반복하며 작업을 수행하는 반면, **`Stream`**은 내부적으로 데이터를 반복하고 작업을 수행한다. 이로 인해 코드가 더 간결해지고, 병렬 처리 등의 최적화도 가능하다.

중간 연산 메서드

- **`filter(Predicate<T> predicate)`**: 주어진 조건에 맞는 요소만 필터링한다.
- **`map(Function<T, R> mapper)`**: 요소를 다른 형태로 변환한다.
- **`sorted()`**: 요소를 정렬한다.

최종 연산 메서드

- **`forEach(Consumer<T> action)`**: 각 요소에 대한 작업을 수행한다.
- **`collect(Collector<T, A, R> collector)`**: 요소를 수집하여 새로운 컬렉션을 생성한다.
- **`count()`**: 요소의 개수를 반환한다.

Stream 예제

```java
public static void main(String[] args) {
        List<String> fruit = Arrays.asList("apple", "banana", "cherry", "date", "fig");

        // 중간 연산: 길이가 4 이상인 단어만 선택하고, 대문자로 변환
        List<String> result = words.stream()
                .filter(word -> word.length() >= 4)
                .map(String::toUpperCase)
                .collect(Collectors.toList());

        // 최종 연산: 결과 출력
        result.forEach(System.out::println);
    }
```

## Generic 이란?

- 데이터의 타입을 일반화하는 것.
- 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법

**Generic의 장점**

1. **타입 안정성** : 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있다.
2. **코드** **재사용성** : 반환 값에 대한 타입 반환 및 타입 검사를 할 필요가 없다.
3. **표현력** : 제네릭을 사용하면 코드를 더 읽기 쉽고 표현력 있게 만들 수 있다 메서드나 클래스의 이름과 인터페이스가 제네릭 타입 매개변수를 사용하여 더 의미 있는 형태로 작성된다.

**예제**

```java
public class GenericClass<T> {
    private T value;

    public GenericClass(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}

public static void main(String[] args) {
    GenericClass<String> stringGeneric = new GenericClass<>("Hello, Generic!");
    String value = stringGeneric.getValue(); // 형변환 필요 없음

    GenericClass<Integer> intGeneric = new GenericClass<>(42);
    int intValue = intGeneric.getValue(); // 형변환 필요 없음
}
```

## Optional이란?

- **`null`** 값으로 인한 예외를 방지하고 코드를 더 안전하게 만드는데 도움을 주는 클래스

**특징**

1. 값**의 존재 유무 표현**: 값이 존재할 수도 있고 없을 수도 있는 상황을 명확하게 v표현한다. 따라서 메서드의 반환값으로 사용하면 호출자에게 해당 메서드가 값을 반환하지 않을 수 있다는 사실을 알려준다.
2. **`null` 방지**: **`null`**을 직접 다루지 않아도 된다. **`null`**을 처리하는 부분에서 발생할 수 있는 예외를 방지하고 코드 안정성을 높인다.
3. **메서드 체이닝**: 메서드 체이닝을 통해 여러 연산을 연속적으로 수행할 수 있다. 이로 인해 코드가 더 간결하고 가독성이 높아진다.
4. **명시적 반환**: 메서드의 반환값이 항상 **`Optional`** 형태로 반환되므로, 해당 메서드가 값을 반환하지 않을 수 있다는 사실을 명시적으로 나타낼 수 있다.

Reference

https://tecoble.techcourse.co.kr/post/2021-04-26-defensive-copy-vs-unmodifiable/

https://jojoldu.tistory.com/412

https://hongchangsub.com/mvcpattern/

https://futurecreator.github.io/2018/08/26/java-8-streams/

https://madplay.github.io/post/java-streams-intermediate-operations
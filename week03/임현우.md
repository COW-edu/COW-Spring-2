# 3주차 학습 PR
학습 PR 역시 로또 리팩토링에 도움이 되는 내용들로 구성되어 있습니다.
해당 개념들을 학습한 뒤, 본인의 로또 코드에 적용까지 해 보신다면..? 비로소 본인 것이 됩니다 ㅎㅎ

아래 `*` 은 여러분들의 학습을 위한 **최소한의** 가이드라인입니다.
꼭 깊이있는 학습 후에 꼼꼼하게 기록해주세요💯

## 일급 컬렉션이란?

* 일급 컬렉션이란?
  일급 컬렉션은 Wrapping하고 그 외 다른 멤버 변수가 없는 상태이다. 컬렉션을 사용할 때에 해당 컬렉션에 조건을 사용하는 경우가
  있다. 예를 들어 컬렉션 내부에 중복되는 값이 있으면 안된다거나 값의 범위가 정해져 있다던가 하는 경우 말이다. 이러한 경우
  컬렉션을 그대로 사용한다면 컬렉션의 조건에 대한 검증을 컬렉션 외부에서 행하게 된다. 그런데 만약 이러한 구조의 컬렉션을 여러 번
  사용한다면 문제가 생긴다. 외부에서의 검증 함수가 컬렉션의 위치마다 존재해야 하며 조건이 바뀌어 구조를 바꾼다면 컬렉션의 위치를
  모두 찾아내어 각각 수정해야만 한다.
  하지만 일급 컬렉션을 사용한다면 다르다. 일급 컬렉션에서는 본인의 상태와 행위를 본인 내부에서 관리한다. 즉, 일급 컬렉션 내부의
  값 중 특정 값을 찾거나 조건의 검증이 일급 컬렉션 내부에서 이루어진다는 것이다. 이를 통해 코드의 중복을 줄이고 변경에 대한 수정이
  용이해진다.
  
* 방어적 복사, unmodifiable Collection
  일급 컬렉션을 불변하게 사용하려면 어떻게 해야할까? 단순히 생각해서 일급 컬렉션 내부에 변경 함수를 넣지 않으면 된다고 생각할 수 있다.
  하지만 우리는 Reference Type이 무엇인지 알고 있다. 때문에 조금만 생각해보면 그런 단순한 방법으로 불변을 보장할 수 없음을 알 수 있다.
  만약 우리가 일급 컬렉션에서 set 함수가 없다 할 지라도 get 함수만으로도 충분히 값을 변경할 수 있는 것이다. 그렇기에 사용하는 것이 바로
  방어적 복사와 unmodifiable Colletion이다.
  방어적 복사는 생성자의 인자 받은 객체의 복사본을 만들고 내부 필드를 초기화하여 사용하거나 get 함수에서 객체의 복사본을 반환하는 것이다.
  이 설명만 들으면 깊은 복사와 유사해 보일 수 있다. 객체의 주소를 복사하는 얕은 복사와 달리 그 주소가 가리키는 공간의 내부 값 그 자체를
  복사하는 깊은 복사는 Reference 타입의 변수를 복사할 때 자주 사용된다. 하지만 깊은 복사와 달리 방어적 복사는 컬렉션의 주소값 만이 다를
  뿐 컬렉션 내부의 원소들의 주소값은 원본과 복사본 모두 같다. 즉 방어적 복사와 깊은 복사 모두 원본에 새로운 원소가 추가 된다하여 복사본에
  새로운 원소가 추가되지 않지만 원본의 원소가 변경되면 복사본에 영향이 없는 깊은 복사와 달리 방어적 복사의 복사본은 원소가 변경된다.
  unmodifiable Colletion의 경우 리턴되는 객체를 읽는 용도로만 사용하게 하는 컬렉션이다. 만약 외부에서 객체를 수정하고자 하면 예외처리를
  통해 수정을 방지한다.
  
* 여담
  현재 진행 중인 OOP Lotto에서 Lotto 클래스 또한 일급 컬렉션이다. 로또 넘버인 List<integer> numbsers만을 필드 변수로 가지며 6개의
  숫자라는 조건에 대한 검증을 내부에서 행하고 있다. 이후 든 생각이 본인의 상태와 행위를 내부에서 관리하기 때문에 당첨번호와의 비교
  또한 내부에서 이루어져야 하는가 라는 의문이 들었다. 하지만 곧 그 생각이 틀렸다고 판단했다. 일급 컬렉션의 장점 중 하나가 변경의
  여파를 줄일 수 있다는 것이다. 일급 컬렉션과 컬렉션의 비교를 일급 컬렉션에서 하게 된다면 만약 일급 컬렉션과 비교되는 컬렉션의 구조가
  바뀌게 된다면 그 여파가 분명 비교 방법에도 영향을 미칠 것이라 생각하였고 그렇게 되면 일급 컬렉션의 본질이 훼손된다고 생각하였다.

## MVC 패턴이란?
<!-- 스프링 MVC 제외하고, 일반적인 MVC에 대해 학습해주세요! -->
응용 프로그램을 Model, View, Controller의 세가지 구성요소로 나누는 소프트웨어 디자인 패턴이다.
Model은 데이터, 자료, View는 유저에게 보여지는 부분, Controller는 Model과 View를 이어주며 Model에게 받은 데이터를 가공할 수 있다.
Model과 View는 다른 구성요소를 알아서는 안되며 오직 Controllrt만이 다른 구성요소들을 보고 모든 흐름을 제어해야 한다.
View는 유저에게 화면을 보여주며 컨트롤러로부터 전달받은 데이터를 화면에 그려내며 그 반대의 경우에도 마찬가지로 이벤트나 정보를 
컨트롤러에게 전달한다.
Model은 데이터를 추출, 저장, 삭제, 업데이트 하는 등 데이터를 다루고 Controller에게 전달한다.
Controller는 사용자의 View를 통한 요청을 Model을 통해 처리하고 그 결과를 다시 View를 통해 유저에게 알린다.

* MVC는 왜 사용하는지?
View와 Model, Controller를 분리하고 View와 Model이 다른 구성요소를 알지 못하게 함으로써 의존성을 최소화하였다. 이를 통해 View나 Model의
변경이 서로에게 여파가 없어지며 관리가 용이해진다.

* MVC 패턴은 왜 등장했는가? 등장 배경?
극초기의 MVC 패턴은 Model과 View가 직접 결합되어 View에서 로직을 처리하는 형태였으나 시간이 지나 분리되며 우리가 아는 MVC의 형태가 되었다.
MVC는 사람과 컴퓨터의 간극을 줄이기 위해 등장하였다. 우리, 즉 사람이 이해하는 형태로 만드는 부분을 View에서 맡는다. 컴퓨터에서의 데이터는
일반인들이 이해하기에는 너무 난해한 형태이기에 View를 통해 사람들에게 친숙한 형태로 만들어준다. 그리고 컴퓨터에게 친숙한 데이터는 Model에서
사용된다. View에서의 인간에게 친숙한 데이터는 변형되어 Model에서 컴퓨터가 처리하기 용이하게 사용된다. 그리고 이 둘 사이를 Controller가
이어주는 것이다.

## Java의 Stream이란?
자바 8 API에 추가된 기능으로 컬렉션 데이터의 처리를 더욱 용이하게 해준다. 
* Stream의 특징? 장점?
  * 병렬 처리
    컬렉션에 대해 병렬 처리를 하기 위해서는 데이터를 분할하고 각각의 스레드를 할당해야 했다. 하지만 스레드는 Race Condition이 발생할 수
    동기화가 필요하다. 또한 마지막에 결과를 합치는 과정이 필요하다. 하지만 스트림의 경우 parallelStream() 함수를 통해 쉽게 병렬 처리가
    가능하다
  * lazy Evaluation
    지연 연산은 결과값이 필요할 때까지 계산을 늦추는 기법이다. 이를 통해 연산을 바로 수행하지 않고 어떤 연산이 필요한 지 판단 후 연산한다.
    예를 들어 1~10 까지의 수 중 짝수를 골라 배열에 그 수에 10을 곱한 값을 넣는 행위를 배열에 값이 3개가 될 때까지 한다고 할 때 이를 Eager(즉시)
    연산하게 하면 1~10까지의 모든 짝수를 골라 낸 뒤 10을 곱하고 값을 넣는다. 하지만 지연 연산을 통하면 짝수 3개를 골라 낸 뒤 10을 곱하고 값을
    넣게 된다. 이렇듯 지연연산을 통해 불필요한 연산을 방지할 수 있다. 
  * 내부 반복 방식
    스트림은 내부 반복을 통해 외부에서의 반복 없이 알아서 반복 처리 후 결과를 얻을 수 있다. 외부 반복을 통한다면 컬렉션에 대해 우리가 원하는
    처리를 할 때 반복문을 통해 각 원소 하나마다 처리를 행해야 한다. 하지만 스트림은 내부 반복을 통해 원하는 처리만 정한다면 알아서 처리 후
    결과를 얻을 수 있다.
  * for문과의 차이점?
    스트림은 for문에 비해 가독성이 뛰어나다. 하지만 에러 발생 시 위치를 바로 알 수 있는 for문과 달리 stream은 지연 연산으로 인해 에러 위치를
    추적해야 한다. 그리고 for문에 비해 비용이 크단느 단점이 있다.
* 중간 연산 메서드
중간 연산은 연산 결과를 스트림 형태로 반환하여 연산을 이어서 할 수 있다.
* 최종 연산 메서드
스트림을 소모하여 다른 형태로 결과를 도출한다. 때문에 스트림을 재사용할 수 없다.
## 제네릭이란?
제네릭은 데이터 형식에 의존하지 않고 하나의 값이 여러 다른 데이터 타입을 가질 수 있게 하는 방법이다. 언어에 따라 다르지만 JAVA는 일종의
Strongly Typed Language로 포인터를 선언할 때 반드시 타입을 명시해야 한다. 만약 제네릭이 없다며 컬렉션 클래스은 타입별로 하나씩 존재해야만
선언할 수 있을 것이다. 하지만 이것은 심각한 코드의 중복을 필요로 한다. 때문에 이를 방지하고자 제네릭을 사용한다. 클래스 내부에서 타입을 
명시하는 것이 아니라 선언 시에 타입을 명시하여 선언하는 것이다. 때문에 컬렉션 클래스와 같이 타입을 미리 명시하는 것이 아닌 선언 시 명시할
경우 사용하기 좋다.
과거에는 Obhect 타입을 사용하였지만 이 경우 Object 타입을 다시 원하는 타입으로 형변환을 해야 했기에 이 과정에서 오류가 발생할 수 있다.
하지만 제네릭을 사용하면 컴파일 시점에서 타입을 지정하기에 이러한 오류가 발생할 일이 없다.

## Optional이란?
Optional은 정의되지 않은 객체에 대해 null 값을 고려하는 경우 null이 오더라도 Null Pointer Exception이 발생하지 않도록 하는 Wrapper 클래스이다.
Optional을 사용할으로써 메서드가 반환한 결과값이 "없음"임을 확실히 하고 NPE를 방지한다. 

## References
<!--학습하시면서 도움이 되었던 참고자료 링크를 기록해주세요!-->
* 일급 컬렉션
  * https://jojoldu.tistory.com/412
  * https://tecoble.techcourse.co.kr/post/2020-05-08-First-Class-Collection/
* MVC 패턴
  * https://hanamon.kr/mvc%EB%9E%80-mvc-design-pattern/
  * https://velog.io/@seongwon97/MVC-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80
  * https://velog.io/@waoderboy/MVC-%ED%8C%A8%ED%84%B4
  * https://ko.wikipedia.org/wiki/%EB%AA%A8%EB%8D%B8-%EB%B7%B0-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC
  * https://velog.io/@eddy_song/mvc
* 자바 Stream
  * https://girawhale.tistory.com/131
  * https://sabarada.tistory.com/154
  * https://ksr930.tistory.com/237
  * https://lotuus.tistory.com/127#%EB%82%B4%EB%B6%80%EB%B0%98%EB%B3%B5%EA%B3%BC_%EC%99%B8%EB%B6%80%EB%B0%98%EB%B3%B5
  * https://hyune-c.tistory.com/entry/for-vs-stream
* 제네릭
  * https://st-lab.tistory.com/153
  * http://www.tcpschool.com/java/java_generic_concept
* Optional
  * https://mangkyu.tistory.com/70
  * https://velog.io/@hope1213/Optional%EC%9D%80-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EC%A7%80-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD

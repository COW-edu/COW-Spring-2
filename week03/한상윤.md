# 3주차 학습 PR

학습 PR 역시 로또 리팩토링에 도움이 되는 내용들로 구성되어 있습니다. 해당 개념들을 학습한 뒤, 본인의 로또 코드에 적용까지 해 보신다면..? 비로소 본인 것이 됩니다 ㅎㅎ

아래 `*` 은 여러분들의 학습을 위한 **최소한의** 가이드라인입니다. 꼭 깊이있는 학습 후에 꼼꼼하게 기록해주세요💯

## 컬렉션 프레임 워크란?

: “자바에서 컬렉션 프레임 워크란 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법

을 제공하는 클래스의 집합이다.”

![1](https://github.com/COW-edu/COW-Spring-2/assets/120346721/ec8c9823-370d-41f1-aad1-27c456d7a89a)

- Set

  자바에서 콜렉션은 크게 List와 Set으로 나뉘어진다. 특히 set은 순서가 없고 집합처럼 중복되지 않는 값들을 처리할 수 있게 해준다.  HashSet은 원소에 가장 빠르게 접근할 수 있다. 또 Set을 상속받은 클래스이기 때문에, 원소의 중복이 없고, 인덱스로 접근이 불가능하다. 원소 존재 유무를 판단하거나, 중복이 없어야 할 때 사용하면 좋은 자료형이다.
  SortedSet은 Set 자료형을 정렬하기 위해 만들어진 인터페이스이다. TreeSet 같은 클래스가 SortedSet 인터페이스를 구현하고 있다. 이것은 내부에 **이진 검색 트리**를 사용해서 요소를 정렬되게 저장한다. 정렬이 된다고 해도 인덱스로 접근은 불가능하다. 대신 iterator 메서드로 배열로 바꿔서 조작할 순 있다. 정수인 경우에도 오른차순으로 정렬이 되고 String인 경우에도 사전식으로 오른차순으로 정렬이 된다. 즉 TreeSet<>에 들어갈 수 있는 요소는 **Comparable** 인터페이스를 구현해야한다.

- Vector와 ArrayList 차이
  Vector와 ArrayList의 차이가 동기화 보장 유무이다. 동기화란 여러 스레드에서 동시에 접근하더라도 안전하게 사용될 수 있게 설계된 것이다. 동기화가 가능하다면, 하나의 스레드가 접근했을 때 다른 스레드가 그것에 대해 접근을 할 수 없다.  Vector인 경우 자동으로 동기화가 보장이 되고 ArrayList인 경우는 수동으로 동기화를 보장할 수 있다. 멀티 스레드 상황에선 안전해지기 때문에 Vector가 좋지만 속도 면에서 좋지 않다.

## 일급 컬렉션이란?

- “일급 컬렉션이란 **Colletion을 Wrapping** 하면서 그 외 **다른 멤버 변수가 없는 상태**를 일급컬렉션이라고 한다.”
  Collection을 Wrapping한다는 의미는 Collection 클래스를 상속 받아서 만들어진 자료구조를 사용할 때, 그것을 따로 클래스로 만들어서 포장한다라는 의미로 해석했다. 그리고 그 외 다른 멤버 변수가 없다는 뜻은 클래스 내에 미리 정해놓은 자료 구조 멤버 변수만이 있어야 한다고 해석했다.  하나의 개념적인 개체를 Collection을 활용해서 클래스로 묶어서 다룬다는 것 같다.
- 일급 컬렉션은 왜 사용하는가? 어떤 장점이 있는지?
  기존의 컬렉션은 주로 데이터를 저장하고 조회하는 용도로 사용되었지만, 일급 컬렉션은 데이터를 처리하기 위한 도구로서의 역할을 강조된다. 얻을 수 있는 장점으로는
  1. 상태와 행위의 결합:
     ○ 일급 컬렉션은 데이터 상태뿐만 아니라 해당 데이터를 조작하기 위한 행위들도 자료구조와 Wrapping 되었기 때문에, 추가,삭제,유무,반환 등을 할 수 있다.
     ○ 개체에 대한 비즈니스의 예외처리도 개체에게 책임을 지게 할 수 있다.
  2. 응집성, 가독성
     ○ 그로 인해서 개체와 관련된 동작들이 한 곳에 모여 있을 수 있어서 코드의 가독성과 유지 보수성이 향상이 된다.
  3. 재 사용성
     ○ 예를 들어, 동아리 클래스에서 사용할 member를 일급 컬렉션으로 만들어서 사용하게 한다면, 동아리 클래스에서 member에 대한 예외처리나, member에 대해서 신경을 쓰지 않아도 된다. 만약 동아리와 성질이 비슷한 학교 반이라는 클래스에서도 member를 사용해야 할 때 member라는 일급 컬렉션을 그대로 사용하면 된다.
  4. 불변.
     일급 컬렉션은 불변을 보장한다고 한다. 자바의 final을 떠올릴 수 있다. 하지만 자료구조를 담는 참조 변수를 final하는 것 그 참조 변수의 내용이 바뀌지 않는 다가 아니라 재 할당이 되지 않는 다를 의미한다.
     일급 컬렉션은 생성자로부터 내용을 받아오고 그것을 객체 내부에 있는 변수에 할당하기 때문에 set이나 이러한 함수로 접근이 불가능하다. **( 클래스를 사용자가 만들었기 때문에 그러한 함수는 존재하지 않는 다.) 이를 통해서 외부의 영향을 절대 받지 않는 개체를 클래스로 만들 수 있다. < = 이것도 맞나요?**

**⇒ 그러면 일급 컬렉션의 최대 목적은 비즈니스에 종속된 자료구조를 클래스로 묶어서 사용하기 위함 인가요??? < = 이것도 맞나요?**

- 방어적 복사 vs Unmodifiable collection
  : 이 두가지는 불변 객체를 다룰 때 나오는 키워드이다. 두 가지 전부 객체 내부의 값을 안전하게 보장하기 위해 사용되어 진다.
  1. 방어적 복사
  : 생성자의 인자로 받은 것을 바로 필드 참조 변수와 연결 시키는 것이 아니라 객체의 복사본을 만들어 내부 필드를 초기화 시키거나, getter 메서에서 내부 객체를 반환할 때, 객체의 복사본을 만들어서 반환하는 것이다.
  방어적 복사를 하면, 외부에서 객체를 변경해도 내부의 객체는 변하지 않는 다.

![Untitled 3](https://github.com/COW-edu/COW-Spring-2/assets/120346721/cfe8f9a1-789d-47ff-a711-1e34349d3c96)
![gg](https://github.com/COW-edu/COW-Spring-2/assets/120346721/851eba62-aa37-44a6-9e12-088ec41277a3)

Names라는 일급 컬렉션을 만들었을 때, 생성자를 바로 내부의 names에 할당하게 된다면,

분명 originalNames에 Kevin까지만 add 했을 때 crewNames에 할당을 했는 데, OriginalNames에  sally를 add를 한다면 crewNames에도 Sally가 추가 된다. 이렇게 된 이유는 crewNames의 필드인 name이 originalNames의 주소를 공유하고 있기 때문에, originalNames의 변화가 그대로 적용이 된 것이다.  이것을 해결하기 위해서

![Untitled 2](https://github.com/COW-edu/COW-Spring-2/assets/120346721/52ab5e6a-836e-4ea6-99ca-128a89772b46)

생성자에서 받은 names를 새로운 객체로 만들어서 복사본을 만드는 것이다. 이러면 originalNames이 변해도 crewNames에 names에는 영향이 가지 않는 다. 하지만 방어적 복사는 깊은 복사가 아니다. 깊은 복사라는 것은 만약 복사를 했다면, 원본과 복사본의 주소는 몰론, 내부 요소들의 주소도 달라야 한다. 하지만 내부 요소들의 주소는 다르지 않다. 그렇기 때문에 밖에서 내부 요소와 주소가 같은 것을 수정한다면, 내부 요소도 같이 수정이 된다.

![Untitled 4](https://github.com/COW-edu/COW-Spring-2/assets/120346721/2ee60f69-0a7f-4e32-b9ab-b56c0453bb25)

그래서 사용되는 것이 Unmodifiable Collection이라는 라이브러리를 사용한다. 이것은 수정할 수 없는, 읽기 전용 컬렉션을 생성한다.`unmodifiableList()`를 사용하면 읽기 전용으로만 사용되는 리스트를 반환한다.  외부에서 값을 변경할려고 할 시에는 예외처리로 막아준다. 그래서 외부에서 객체에 .set 이렇게 변화시킬 수 없게 만든다.
즉 생성자의 인자 객체를 받았을 때 외부 객체의 변화가 내부 객체에 영향을 끼치지 못하도록 하는 것이 방어적 복사이고, getter를 통해 객체를 줄 때, 복사본을 주던 가, 아니면 Unmodifiable Collection을 사용해서 읽기전용으로 객체를 주라는 의미이다.

**??? 질문입니다.**

![Untitled 5](https://github.com/COW-edu/COW-Spring-2/assets/120346721/0794462a-657c-4693-baf8-91e90e8d2467)

**지금 불변하게 만들기 위해서 방어적 복사와 Unmodifiable Collection을 얘기했습니다.**

**그런데 위의 사진은 만약 Unmodifiable Collection만을 썼을 땐 원본 자체에 대한 수정이 일어나면 읽기 전용 리스트여도 거기안에 있는 내용도 수정된다는 얘기이고, 만약 방어적 복사와 Unmodifiable Collection을 같이 쓴다면, 상관 없는 거겠죠?? 복사본을 읽기 전용으로 주는 거니까??**

## MVC 패턴이란?

- MVC는 왜 사용하는지?

MVC패턴은 모델-뷰-컨트롤 패턴으로 소프트웨어를 구조화하고 모듈화 하는 데 사용되는 디자인 패턴이다.  이 패턴의 특징은 소스 코드를 관리하고 유지보수성을 높인다.

1. 모델 : 데이터를 관리하는 매니저로써 데이터의 CRUD를 담당한다.
2. 뷰 : 사용자 인터페이스(UI)를 담당하며, 데이터 표시와 사용자 입력 처리 등을 수행한다.
3. 컨트롤러: 모델과 뷰 사이의 상호작용을 조정한다. 비즈니스적인 로직이 들어가있는 곳이다.

즉 뷰는 사용자와 맞닿아있는 면으로 사용자의 요청을 컨트롤에게 전달하고 컨트롤이 모델에게 적절한 요청을 보내고 데이터는 연결된 DB나 데이터를 컨트롤에 전달하고 컨트롤이 그것을 처리하여 적절한 응답을 뷰에게 전달하고 뷰는 그것을 가공된 형태로 내보낸다. 그 외에도 유연성과 재사용성,확장 가능성,개발 협업 용이성을 확보할 수 있다.

내가 생각하는 생각하는 사용하는 추가적인 이유는 안전하고 독립적으로 프로그램이 실행되기 위해 사용하는 것 같다. 뷰는 사용자와 맞닿아 있기 때문에 취약하다고 생각이 든다. 만약 데이터를 관리하는 부분과 같이 있다면 보안에 굉장히 큰 문제가 생길 것 같다. 그래서 보안 때문에도 나누는 것 같다.

- MVC 패턴은 왜 등장했는가? 등장 배경?

MVC 패턴이 등장하게 된 특별한 계기는 기존의 패턴은 기존에 사용자 인터페이스와 비즈니스 로직이 강하게 결합되어 있었다. 하지만 Smalltalk 언어와 그래픽 사용자 인터페이스(GUI) 개발 환경의 발전으로 인해 새로운 디자인 패턴이 만들어 질 수 있었고 그것이 MVC 패턴이다. 조금 더 자세한 상황 설명으로는,
Smalltalk란 1970년대에 Xerox PARC 연구소에서 개발된 객체지향 프로그래밍 언어이다. 이 언어는 GUI 개발에 적합한 기능과 도구를 제공하며, 객체지향 프로그래밍의 원리를 잘 반영하고 있었다.

Smalltalk에서 GUI 개발을 위해 MVC 패턴이 처음으로 도입되었다. 그 당시 GUI 애플리케이션은 사용자 인터페이스, 데이터 처리 및 비즈니스 로직이 강하게 결합되어 있었는데, 이로 인해 유지보수에 문제를 겪었다.  그래서 MVC 패턴이 이러한 문제를 해결하기 위해서 사용자 인터페이스와 비즈니스 로직을 분리하는 방법으로 제시가 된 것이다.

## Java의 Stream이란?

- Stream의 특징? 장점?
  - 병렬 처리
  - 작업 분류
  - lazy Evaluation
  - 내부 반복 방식
  - for문과의 차이점?
- 중간 연산 메서드
- 최종 연산 메서드

### Stream의 특징? 장점?

자바 8버부터 등장한 API로, 자바에는 많은 데이터를 콜렉션(배열, 리스트)로 다루는 데, 그것들의 안에 있는 데이터를 함수형 파이프 스타일로 처리할 수 있게 해준다.

“스트림이란 '데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소'로 정의할 수 있다.”

이 뜻을 해석하면, 소스(컬렉션, 배열, I/O 자원 등으로부터 온 데이터들)에서 추출해서 그게 Stream이 되고 중간 연산(map, filter,sorted)를 통해 그 요소에 적용이 되고(원본 데이터에는 영향이 끼지치 않는 다.) 그것을 반환하는 것이라고 생각한다.

이것의 특징은

1. 외부 반복을 통해 작업하지 않고 내부 반복을 통해 작업을 수행한다.
2. 스트림은 재사용이 가능하지 않고 한번만 사용이 된다.
3. 스트림은 원본 데이터에 영향을 끼치지 않는 다.

이것의 장점은

1. 코드의 가독성이 좋아진다. Collection에 대한 반복문을 매번 적어야 하는 것을 함수 하나로 해결할 수 있다.(하지만 그저 반복만 할 뿐이라면, 성능은 for문이 더 좋다.) 그 뿐만이 아니라, 정렬이라든 지, 필터링을 해야할 때 연속된 함수(**파이프 라이닝**)을 통해서 그 요소들을 처리할 수 있다.
2. 원본 데이터에 영향을 끼치지 않기 때문에, 원본 데이터를 보존할 수 있다.
3. **지연 평가**라는 것을 통해 필요한 시점에 연산을 할 수 있어서 효율적인 메모리 사용이 가능하다.
4. Stream을 **병렬로** 처리할 수 있어서 성능을 더 높일 수 있다.

### 병렬 처리

병렬 처리란 멀티코어 환경에서 공통된 작업을 분할해서 여러 CPU가 그것을 동시에 처리하는 것을 의미한다. 스레드란 프로그램 실행의 기본 단위로, CPU가 처리할 수 있는 프로그램의 단위로도 볼 수 있다. 이런 스레드를 동시에 사용한다면, 일반적으로 성능 향상을 기대할 수 있다.

Stream API에선 중간 연산 메서드로 parallelSteam() (<=>sequential() : 병렬화 취소 )를 호출함으로써 Stream의 요소들을 병렬로 처리할 수 있다. 여기서 병렬처리를 하기 위해 Fork/Join 프레임워크를 사용한다. 자바 7에서 소개된 기능으로 분할 정복 알고리즘을 통해 재귀적으로 처리된다.

밑에는 병렬 처리로 한 것으로 요소가 일정하게 반환된 것이 아니라 랜덤으로 반환 된 것을 확인할 수 있다.

![Untitled 6](https://github.com/COW-edu/COW-Spring-2/assets/120346721/4d0fdbe7-fe60-4c50-8cd4-89af82df7c72)

### 작업 분류

Stream 클래스에서의 작업 분류는 주로 중간 연산(Intermediate Operation)과 최종 연산(Terminal Operation)으로 구분된다.

1. 중간 연산(Intermediate Operation):
  - 중간 연산은 스트림을 변환하거나 필터링하는 작업이다.
  - 예를 들어 `filter()`, `map()`, `flatMap()`, `distinct()` 등이 있다.
    **- 중간 연산은 지연 평가(lazy evaluation) 방식으로 동작하여 실제 결과를 요구하기 전까지 실 행 되지 않는 다.**
- `filter()`

  .filter( 요소 → 조건식) 이런식으로 사용한다.

  이런식으로 bolean을 반환하는 조건식이 들어가야 한다.


![Untitled 7](https://github.com/COW-edu/COW-Spring-2/assets/120346721/465aff0e-a935-456b-ae00-49fe2d480a33)

- `map()`
  .map( 요소 → 요소에 적용할 식)
- `flatMap()`
  중첩된 구조를 한 단계 없애고 단일 원소 스트림으로 만든다.

![Untitled 8](https://github.com/COW-edu/COW-Spring-2/assets/120346721/082dbd15-e152-4aa9-874e-ce23a6aca560)

- `distinct()`
  스트림 내의 중복된 요소의 중복을 제거한다. primitive type일 경우에는 값으로 비교하지만 객체인 경우에는 object.equals로 비교해야한다.
- `sorted()`
  스트림 내의 요소를 정렬할 수 있다. 하지만 IntStream, DoubleStream, LongStream과 같은 primitive type 특화 스트림일 경우에는 sorted 메서드의 인자를 줄 수 없다. 따라서 boxing 메서드를 이용해 객체 스트림으로 변환 시켜준다음 줘야한다.
  매개인자로는 Comparator.reverseOrder()로 내림차순으로 바꿀 수 있다.
- `peek()`
  각각의 요소에 단말 연산을 수행한다. 각 각의 요소에 사칙연산 같은 특정 연산을 수행하게 할 수 있다. 원본 스트림에서의 값을 해치지 않기 때문에, 중간 연산을 확인하는 용도로 좋다.
- `limit()`
  스트림내의 요소의 개수를 제한할 수 있다.
- `skip()`
  스트림 내의 첫 번째 요소부터 인자로 받은 숫자만 큼을 제외한 나머지 요소를 리턴한다.
- `boxed()`
  위에서 언급했다 싶이 기본형 스트림을 객체 스트림으로 바꾼다.
1. 최종 연산(Terminal Operation):
   -최종 연산은 스트림의 요소들에 대한 최종 결과를 반환하는 작업이다.
   -예를 들어 `forEach()`, `collect()`, `reduce()`, `count()` 등이 있다.
  - 최종 연산은 스트림을 소모하며, 실행 시점에 모든 **중간 연산이 수행**되고 결과가 생성된다.
- `forEach()`
  : 각 스트림의 요소를 소모하며 출력한다.
  - `reduce()`
  : 각 스트림의 요소를 축소 하거나 결합해서 **단일** 값을 생성하는 연산이다.
  주로 숫자나 문자열에 사용된다. 첫 번째 인자는 초기값으로 만약 stream이 비었을 때는 초기값만을 반환하고, 요소가 있어서 연산을 할 때도 초기값부터 시작해서 연산을 한다. 정수 중의 최솟값이나 최댓값을 구할 때 자주 사용한다.

  **List<Integer> numbers = Arrays.asList(7, 2, 10, 4, 3);
  int min = numbers.stream().reduce(Integer.MAX_VALUE, (a, b) -> Math.min(a, b));**

- `anyMatch()`, `allMatch()`, `noneMatch()`
- anyMatch(조건식) : 스트림의 요소 중 하나라도 조건식을 만족하면 true를 반환.
- AllMatch(조건식) : 스트림의 모든 요소가 조건식을 만족할 때 true를 반환.
- noneMatch(조건식) : 스트림의 모든 요소가 조건식을 만족하지 않을 때 true를 반환.
- Stream 요소 통계
- `count()` : 해당 스트림 요소의 총 개수를 반환한다.
- `max()` : 해당 스트림 요소 중의 최대값을 반환한다.
- `min()` : 해당 스트림 요소 중의 최솟값을 반환한다.

![Untitled 9](https://github.com/0702Yoon/COW-Spring-2/assets/120346721/c8c151f5-87d7-4620-83fa-65028453c2b4)

stream3인 경우 String이기 때문에 객체 비교를 위해 Comparator를 써야 비교가 가능하다.

- Stream의 요소 연산
- sum(), average() : IntStream 이나 DoubleStream에서 사용할 수 있는 모든 요소의 합과 평균을 받을 수 있다.
  이때 요소의 평균을 구할 때 average()의 결과로 OptionalDouble을 반환하기 때문에 getAsDouble() 혹은 getAsInt()로 값을 받는 다. 이때 getAsDouble()로 값에 접근하기 전에 OptionalDouble이 실제로 존재하는 지 .isPresent()로 확인하고 접근해야 안전하다.
- collect()
  스트림의 요소를 모아서 다양한 데이터 구조로 변환 시키는 최종 연산이다. Collector를 매개 인자로 받아서 스트림 요소를 어떻게 모을 지 정의한다.
1. 스트림을 배열이나 컬렉션으로 반환
- Collectors.toList() : List로 수집
- Collectors.toSet()  : 집합으로 수집
- Collectors.joinning(”,”)  : 문자열로 수집
- Collectors.toMap(SomeObject::getId, SomeObject::getName) : 요소의 특정 속성을 키로 사용
2. 요소의 통계와 연산메서드와 같은 동작을 수행
- counting()
- maxBy()
- minBy()
- summingInt()
- averageInt()
3. 요소의 소모와 같은 동작을 수행
- reducing(), joining()
4. 요소의 그룹화와 분할
- groupingBy(), partitioningBy()..

중간 연산과 최종 연산을 조합하여 Stream API에서 다양한 데이터 처리 작업을 수행할 수 있습니다. 이러한 분류는 Stream API의 함수형 프로그래밍 특성과 함께 사용자가 원하는 데이터 처리 로직을 간결하게 표현할 수 있도록 돕는다.

### 내부 반복 방식 과 for문과의 차이점

for문은 흔히 for(int i = 0 ; i< number.size() ; i++){} 이런식으로 사용되어 진다. 바디를 한번 수행한 다음에 매번 조건식을 확인한다. 그래서 number.size()라는 함수가 매번 호출된다. 즉 사용자가 제어 흐름을 만들고, 매 반복마다 조건을 체크하면서 반복적으로 처리하는 것이다.

하지만 내부 반복 방식 (forEach 메서드)는 제어 흐름을 직접 명시하지 않는 다. 이것이 가능한 이유는 Iterable 인터페이스와 Iterator 인터페이스가 등장때문이다.  그래서 내부 반복 방식은 hasNext()와 next() 메서드의 반복으로 실행되는 구조이다.  그래서 for-each문을 사용하기 위해선 Iterable 인터페이스를 구현한 객체만이 실행할 수 있다. 이것은 요소들의 전체를 내부적으로 자동 반복하고 처리한다. 그래서 오히려 for문보다 느리다는 단점이 존재한다. 하지만 가독성과 편리함, 그리고 제어 흐름에서 나올 수 있는 예외를 신경 안쓸 수 있는 안전함을 얻을 수 있다.

※ Iterable인터페이스와 Iterator 인터페이스

Iterable 인터페이스는 Collection의 상위 인터페이스다. 그렇기 때문에 Collection을 구현하고 있는 List나 Set, Queue는 Iterable 인터페이스를 구현해야한다. Iterable이란 순회가 가능한 이라는 뜻을 가지고 있다. 그래서 순회 가능한 자료형클래스로 만들어 진 것이다. Iterator 인터페이스는 콜렉션을 상속하거나 받는 관계가 아니다. Iterator 인터페이스의 내부 구현은 hasNext(), next(), remove()등의 메서드를 이용할 수 있다. 이것은 컬렉션 클래스의 데이터를 하나씩 읽어올 때 마다 사용한다. 즉 Iterable이 가능한 자료 구조안에 있는 데이터를 다루기 위한 인터페이스 인 것이다.

### lazy Evaluation

Lazy Evaluation(지연 평가)은 프로그램에서 연산이 필요한 시점까지 연산을 미루는 기법이다.

즉, 결과를 사용하는 시점에 해당 연산을 실행된다.

일반적으로 명령형 프로그래밍에서는 코드의 실행 순서에 따라 연산이 즉시 되지만. Lazy Evaluation은 필요한 결과가 실제로 필요한 시점까지 계산하지 않고, 그때까지 연기한다. 이를 통해 불필요한 계산을 최소화하고, 효율적인 처리를 할 수 있다.

## 제네릭이란?

제네릭 타입이란 다양한 타입의 객체를 다룰 수 있도록 일반화된 타입을 나타내는 기능이다. 제네릭타입을 사용하면 클래스나, 메소드를 정의할 때 실제 사용될 타입을 지정하지 않아도 된다. 즉 String, Integer 변수 중 어떤 거를 쓸건지 미리 정하지 않고 <T> 이것으로 대신 받아서 String이면 String으로 되고 Integer면 Integer로 사용할 수 있게 하는 기능이다. 하지만 이 때 주의해야하는 건 primitive타입은 안되고 참조변수만이 가능하다.

## Optional이란?

Optional이란 값의 존재 여부를 명시적으로 표현하고, null 체크를 간편하게 처리할 수 있도록 도와주는 컨테이너 클래스이다.

이것을 사용하면 얻을 수 있는 장점으로는

1. Null의 안전성 : Optional은 값을 감싸는 컨테이너같은 역할을 한다. 그래서 Optional 객체는 Null이라는 값도 가질 수 있다. 이를 통해서 NullPointerException 오류를 방지하고 안전한 코드 작성에 도움을 준다.
2. 명시적인 값의 존재 여부 : 이 Optional 객체는 값이 존재하는 지에 대한 여부를 명확하게 나타낼 수 있다. 원래는 null에 접근 하면 NullpointerException이 발생하지만 이것은 boolean값을 반환하는 메서드를 사용하면 조건문에 바로 사용할 수 있다.
3. 기본값 설정 : 값이 없는 경우에 거기에 기본 값을 할당할 수 있다.

이를 통해 null이라는 특별한 개념에 대한 안전성과 가독성을 얻을 수 있다.

## References

- 컬렉션
  https://gangnam-americano.tistory.com/41
  [https://inpa.tistory.com/entry/JCF-🧱-ArrayList-vs-Vector-동기화-차이-이해하기](https://inpa.tistory.com/entry/JCF-%F0%9F%A7%B1-ArrayList-vs-Vector-%EB%8F%99%EA%B8%B0%ED%99%94-%EC%B0%A8%EC%9D%B4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)
  https://shyvana.tistory.com/14
- 일급 컬렉션
  [https://velog.io/@seongwon97/일급-컬렉션이란](https://velog.io/@seongwon97/%EC%9D%BC%EA%B8%89-%EC%BB%AC%EB%A0%89%EC%85%98%EC%9D%B4%EB%9E%80)
  https://jojoldu.tistory.com/412
  https://tecoble.techcourse.co.kr/post/2021-04-26-defensive-copy-vs-unmodifiable/
- MVC패턴
  https://mundol-colynn.tistory.com/147
- Stream
  https://ict-nroo.tistory.com/43
  https://hyune-c.tistory.com/entry/for-vs-stream
  https://devlog-wjdrbs96.tistory.com/84
  https://tecoble.techcourse.co.kr/post/2020-08-31-java-loop/
- Optional
  https://mangkyu.tistory.com/70

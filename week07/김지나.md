## **7주차 학습 PR**

### **싱글톤 패턴이란?**

- 소프트웨어 디자인 패턴에서 싱글턴 패턴(Singleton pattern)을 따르는 클래스는, 생성자가 여러 차례 호출되더라도 **실제로 생성되는 객체는 하나**이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다.
- 간단히 설명하면 싱글톤 패턴은 **객체의 인스턴스를 한개만 생성되게 하는 패턴이다.**
- 즉, 싱글톤 패턴은 아래와 같은 상황에 사용한다.
    - 프로그램 내에서 하나의 객체만 존재해야 한다.
    - 프로그램 내에서 여러 부분에서 해당 객체를 공유하여 사용해야한다.

- 싱글톤 패턴의 이점은?

  **1. 메모리 측면의 이점**

  싱글톤 패턴을 사용하게 된다면 한개의 인스턴스만을 고정 메모리 영역에 생성하고 추후 해당 객체를 접근할 때 메모리 낭비를 방지할 수 있다.

  **2. 속도 측면의 이점**

  생성된 인스턴스를 사용할 때는 이미 생성된 인스턴스를 활용하여 속도 측면에 이점이 있다.

  **3. 데이터 공유가 쉽다**

  전역으로 사용하는 인스턴스이기 때문에 다른 여러 클래스에서 데이터를 공유하며 사용할 수 있다. 하지만 동시성 문제가 발생할 수 있어 이 점은 유의하여 설계하여야 한다.

    - 동시성 문제란?
        - 여러 스레드가 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 문제
        - 중요한 점은 값에 무조건 동시에 접근한다고 문제가 발생하는 것이 아니라 값을 어디선가 **변경**할 때 발생한다.
        - 스레드는 별도의 stack 영역을 갖기 떄문에, 인스턴스를 갖도록 설계하지 않고 지역변수나 매개변수 등으로 객체를 넘겨서 사용하게 되면 적은 노력으로 동시성 이슈를 피할 수 있다.


### **싱글톤 컨테이너란?(feat.싱글톤의 단점..?)**

- 싱글톤 패턴은 많은 문제들을 가지고 있다.
    - 싱글톤 패턴을 적용하기 위해 구현할 코드양이 많아지면서 비용이 늘어난다.
        - 싱글톤 패턴은 클래스 내에서 하나의 유일한 인스턴스를 생성하고 유지해야 한다. 이를 위해 인스턴스 변수를 선언하고, 생성자를 private으로 만들어야 한다. 또한 인스턴스를 얻거나 생성하는 메서드를 만들어야 한다. 싱글톤 패턴을 구현하는 데에 이 모든 코드가 필요하므로 코드 양이 늘어나게 된다.
    - 의존관계상 클라이언트가 구현체에 의존하면서 DIP를 위반하게 된다.
    - DIP를 위반하면 자연스럽게 OCP를 위반할 가능성도 높아진다.
    - 테스트가 어려워진다.
        - 인스턴스를 미리 다 받아서 설정이 끝난 상태이기에 유연한 테스트가 힘들다.
    - 내부 속성을 변경하거나 초기화가 어렵다.
    - private 생성자로 자식 클래스를 만들기 어렵다.
    - 유연성이 떨어진다.

  → 하지만 스프링 컨테이너에서는 싱글톤의 이러한 단점들을 해결하면서 장점만 가지는 싱글톤을 사용한다.

- 싱글톤 컨테이너
    - 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도 싱글톤으로 객체들을 관리한다.
    - 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이처럼 싱글톤 객체를 생성 및 관리하는 기능을 **싱글톤 레지스트리**라 한다.
    - 이렇게 스프링 컨테이너에서 싱글톤 컨테이너 역할을 해줌으로써 싱글톤 패턴의 단점을 없애고 객체의 단일성을 유지할 수 있다.

      → 그렇기에 각각의 빈들은 싱글톤 패턴 적용을 위한 코드를 작성할 필요가 없다.
      → 더하여 DIP, OCP, 테스트, private 생성자를 고민하지 않아도 된다.


### **Java의 POJO란 무엇인가?(feat.Spring의 Bean)**

![image](https://github.com/COW-edu/COW-Spring-2/assets/108182934/b02c0dbc-3fb8-4ea0-bbc2-b155dfa3d244)

- POJO란 Plain Old Java Object의 약자로, 이를 직역하면 순수한 오래된 자바 객체이다. 즉, Java로 생성하는 순수한 객체를 뜻한다.
- 위 이미지는 Spring 삼각형이라는 유명한 이미지로 Spring의 핵심 개념들을 모두 표현하고 있다. POJO는 IoC/DI, AOP, PSA를 통해서 달성할 수 있다는 것을 의미한다.
- POJO는 객체 지향적인 원리에 충실하면서 환경과 기술에 종속되지 않고, 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 의미한다. 이러한 POJO에 애플리케이션의 핵심 로직과 기능을 담아 설계하고 개발하는 방법을 `POJO 프로그래밍`이라고 한다.

- POJO 프로그래밍
    - POJO를 이용하여 프로그래밍 코드를 작성하는 것이다. 그러나 순수 자바 객체만을 사용한다고 해서 POJO 프로그래밍이라고 볼 수는 없다.
    - POJO 프로그래밍으로 작성한 코드가 되기 위해서는 기본적인 규칙들을 지켜야 한다.
        1. Java나 Java의 스펙에 정의된 것 이외에는 다른 기술이나 규약에 얽매이지 않아야 한다.
            - Java 프로그래밍에서 자바 언어와 자바 플랫폼의 표준 스펙에는 의존성을 가질 수 있지만, Java 이외의 외부 기술, 프레임워크, 라이브러리, 또는 규약에 대한 의존성을 최소화해야 한다는 의미
        2. 특정 환경에 종속적이지 않아야 한다.
            - 자체 개발한 코드와 Java 표준 라이브러리를 주로 사용하며, 특정 프레임워크나 플랫폼에 강하게 의존하지 않아야 한다.

    - POJO 프로그래밍이 필요한 이유
        - 특정 환경이나 기술에 종속적이지 않으면 재사용이 가능하고, 확장 가능한 유연한 코드를 작성할 수 있다.
        - 저수준 레벨의 기술과 환경에 종속적인 코드를 제거하여 코드를 간결해지며 디버깅하기에도 상대적으로 쉬워진다.
        - 특정 기술이나 환경에 종속적이지 않기 때문에 테스트가 단순해진다.
        - **객체지향적인 설계를 제한 없이 적용할 수 있다.**


### **스프링의 사용 이유, 장점이나 특징(이거 중요!!)**

1. POJO 프로그래밍을 지향
    - POJO는 순수 Java만을 사용하여 만든 객체이므로 특정 기술이나 환경에 종속되지 않는다. 따라서, **외부 기술이나 규약의 변화에 얽매이지 않아, 보다 유연하게 변화와 확장에 대처할 수 있다.** 이러한 POJO를 사용하여 비즈니스 로직을 구현하면 **객체지향 설계를 제한없이 적용할 수 있으며, 코드가 단순해져 테스트와 디버깅 또한 쉬워진다.**
    - 메소드나 객체(bean)의 호출 작업은 제어의 역전을 통해 외부에서 이루어진다.
    - 제어의 역행을 전제조건으로 DI가 일어난다.
    - 의존성을 가진 객체에 대해 스프링에서 의존성 주입이 발생하도록 한다.
    - 의존성 주입 특성으로 인해 개발자가 POJO 개발이 가능하게 된다.

2. PSA(Portable Service Abstraction, 일관된 서비스 추상화)
    - 만일, 개발을 하던 중 사용 중이던 DB를 바꿔야 하는 상황이 왔을 떄, 각 DB 마다 사용 방법이 다르다면 코드를 모두 수정해 주어야 한다.
    - 그러나 스프링을 사용하면 동일한 사용방법을 유지한 채로 데이터베이스를 바꿀 수 있다. 이는 **스프링이 데이터베이스 서비스를 추상화한 인터페이스를 제공해주기 때문에 가능**하다.
    - 즉, 스프링은 Java를 사용하여 데이터베이스에 접근하는 방법을 규정한 인터페이스를 제공하고 있으며, 이를 J**DBC(Java DataBase Connectivity)**라고 한다.
    - 각 데이터베이스를 만든 회사들은 자신의 데이터베이스에 접근하는 드라이버를 Java 코드의 형태로 배포하는데, **이 드라이버에 해당하는 Java 코드의 클래스가 JDBC를 구현합니다.** 따라서, JDBC를 기반으로 하여 데이터베이스 접근 코드를 작성해두면, 이후에 데이터베이스를 바꾸어도 기존에 작성한 데이터베이스 접근 로직을 그대로 사용할 수 있다.
    - 이러한 JDBC처럼 **특정 기술과 관련된 서비스를 추상화하여 일관된 방식으로 사용될 수 있도록 한 것을 PSA(Portable Service Abstraction, 일관된 서비스 추상화)라고 한다.**

3. AOP(관점지향 프로그래밍) 지원
    - 애플리케이션을 개발할 때에 구현해야 하는 기능들은 크게 **공통 관심 사항**과 **핵심 관심 사항**으로 분류할 수 있다. 먼저, **핵심 관심 사항은 애플리케이션의 핵심 기능과 관련된 관심 사항**으로, 커피 주문 애플리케이션을 예로 든다면 메뉴 등록하기, 주문하기, 주문 변경하기 등이 있다.
    - 반면, **공통 관심 사항은 모든 핵심 관심 사항에 공통적으로 적용되는 관심 사항들을 의미한다.** 예를 들어, 메뉴 등록하기, 주문하기, 주문 변경하기 등 모든 핵심 관심 사항에는 로깅이나 보안 등과 관련된 기능들이 공통적으로 적용되어야만 한다.
    - 이 때, 핵심 관심 사항과 공통 관심 사항이 코드에 함께 모여 있으면 필연적으로 **공통 관심 사항과 관련된 코드가 중복**될 수밖에 없다. 이처럼 코드가 중복되어져 있는 경우, **공통 관심 사항을 수행하는 로직이 변경되면 모든 중복 코드를 찾아서 일일이 수정해주어야만 한다.**
    - 코드의 중복이라는 문제를 해결하기 위해서는 공통 관심 사항과 관련된 기능들을 별도의 객체로 분리해낸 다음, 분리해낸 객체의 메서드를 통해 공통 관심 사항을 구현한 코드를 실행시킬 수 있도록 해야 한다. 이처럼, 애플리케이션 전반에 걸쳐 적용되는 공통 기능을 비즈니스 로직으로부터 분리해내는 것을 AOP(Aspect Oriented Programming, 관심 지향 프로그래밍)라고 한다.

### **스프링에서 사용되는 어노테이션 10개 이상 정리하기**

- `Annotation`은 클래스와 메서드에 추가하여 다양한 기능을 부여하는 역할을 한다. Annotation을 활용하여 Spring Framework는 해당 클래스가 어떤 역할인지 정하기도 하고, Bean을 주입하기도 하며, 자동으로 getter나 setter를 생성하기도 한다. 이러한 Annotation을 통하여 **코드량이 감소하고 유지보수하기 쉬우며, 생산성이 증가된다.**
- @Component
    - 개발자가 생성한 Class를 Spring의 Bean으로 등록할 때 사용하는 Annotation
    - Spring은 해당 Annotation을 보고 Spring의 Bean으로 등록
- ****@ComponentScan****
    - Spring Framework는 @Component, @Service, @Repository, @Controller, @Configuration 중 1개라도 등록된 클래스를 찾으면, Context에 bean으로 등록
    - @ComponentScan Annotation이 있는 클래스의 하위 Bean을 등록 될 클래스들을 스캔하여 Bean으로 등록
- ****@Bean****
    - @Bean Annotation은 개발자가 제어가 불가능한 외부 라이브러리와 같은 것들을 Bean으로 만들 때 사용
- ****@Controller****
    - Spring에게 해당 Class가 Controller의 역할을 한다고 명시하기 위해 사용하는 Annotation
- @****RequestHeader****
    - Request의 header값을 가져올 수 있으며, 해당 Annotation을 쓴 메소드의 파라미터에 사용
- @****RequestMapping****
    - @RequestMapping(value=”“)와 같은 형태로 작성하며, 요청 들어온 URI의 요청과 Annotation value 값이 일치하면 해당 클래스나 메소드가 실행
    - Controller 객체 안의 메서드와 클래스에 적용 가능하며, 아래와 같이 사용
        - Class 단위에 사용하면 하위 메소드에 모두 적용
        - 메소드에 적용되면 해당 메소드에서 지정한 방식으로 URI를 처리
- ****@ResponseBody****
    - @ResponseBody은 메소드에서 리턴되는 값이 View 로 출력되지 않고 HTTP Response Body에 직접 쓰인다.
    - return 시에 json, xml과 같은 데이터를 return
- ****@RequestParam****
    - URL에 전달되는 파라미터를 메소드의 인자와 매칭시켜, 파라미터를 받아서 처리할 수 있는 Annotation
    - Json 형식의 Body를 MessageConverter를 통해 Java 객체로 변환
- ****@Autowired****
    - Spring Framework에서 Bean 객체를 주입받기 위한 방법은 크게 3가지가 있다.
        - @Autowired
        - 생성자 (@AllArgsConstructor 사용)
        - setter
    - Bean을 주입받기 위하여 @Autowired 를 사용 Spring Framework가 Class를 보고 Type에 맞게(Type을 먼저 확인 후, 없으면 Name 확인) Bean을 주입
- ****@SpringBootTest****
    - Spring Boot Test에 필요한 의존성을 제공
- ****@Test****
    - JUnit에서 테스트 할 대상을 표시

### **controller - service - repository란?**

1. **Controller**:
    - Controller는 웹 애플리케이션에서 HTTP 요청을 처리하고 클라이언트에게 HTTP 응답을 제공하는 역할
    - 클라이언트에서 HTTP 요청을 보내면 Controller는 해당 요청을 처리하고 비즈니스 로직을 호출하거나 다른 서비스와 상호작용
    - 주요 역할은 요청을 라우팅하고 모델 및 뷰를 결합하여 클라이언트에게 응답을 제공
    - 스프링 프레임워크에서는 **`@Controller`** 어노테이션을 사용하여 Controller 클래스를 정의하며, 이러한 클래스는 특정 URL 경로에 매핑된다.
2. **Service**:
    - Service는 비즈니스 로직을 포함
    - Controller에서 요청을 받아와서 해당 요청에 대한 비즈니스 로직을 처리하거나, 데이터베이스와 상호작용하는 역할
    - Service는 코드를 재사용하고 애플리케이션의 모듈화를 촉진하는 데 사용
    - 주요 역할은 비즈니스 로직을 구현하고, 이 로직이 잘 작동하도록 하는 것
    - 스프링에서는 **`@Service`** 어노테이션을 사용하여 Service 클래스를 정의하며, 이러한 클래스는 주로 Controller와 Repository 사이에서 중재자 역할로 이루어짐.
3. **Repository**:
    - Repository는 데이터베이스와 상호작용하여 데이터를 저장, 검색, 업데이트, 삭제하는 역할
    - 데이터에 접근하는 역할로, 데이터베이스와 직접 상호작용하는 코드를 캡슐화
    - 주로 데이터베이스와의 통신을 추상화하고 데이터 액세스 코드를 관리
    - 스프링에서는 **`@Repository`** 어노테이션을 사용하여 Repository 클래스를 정의하며, 이러한 클래스는 데이터베이스 연동을 위한 CRUD(Create, Read, Update, Delete) 작업을 수행


즉, Controller는 클라이언트와 상호작용하고, Service는 비즈니스 로직을 처리하며, Repository는 데이터베이스와의 상호작용을 담당한다.

### **(선택) 지난 세션에서 추가적으로 궁금했던 것들 자유롭게 기록**

지난 세션이나 학습 pr을 공부하시면서 어 그럼 이건 뭐지..? 하는 궁금증이 생겨난다면, 더 깊이있게 학습하시고 소제목(###)을 추가적으로 달아서 정리해보세요!!

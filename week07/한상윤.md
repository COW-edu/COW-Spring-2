# 7주차

1. 싱글톤 패턴이란?
2. 싱글톤 컨테니어란?( 싱글톤의 단점)
3. Java의 POJO란 무엇인가?( feat. Spring의 Bean)
4. 스프링의 사용 이유, 장점이나 특징
5. 스프링에서 사용되는 어노테이션 10개 이상 정리하기
6. controller - service - repository란?

1. **싱글톤 패턴이란?**
   싱글톤 패턴이란 소프트웨어 디자인 패턴 중에 하나로, 어떠한 객체가 단 한번만 생성되는 것을 보장한다.
   나는 처음에 생각했을 때 프로그래머가 소스 코드상에서 객체를 한번만 생성하고 그것의 주소를 계속해서 반환해서 그거 하나만 사용하는 방식이라고 생각을 했었다. 하지만 그런 접근이 아니라 아예 특정 객체가 무조건 한번만 생성이 되게 만드는 개념이란 것을 알게 되었다.
   당연히 생각이 들었던 것은 그것을 하기 가장 좋은 메모리는 static 세그먼트겠지 였다. 왜냐하면, 딱 한번만 만들어서 그것을 공유해서 사용하기 때문에 어디서든 접근 할 수 있게 그것을 static 멤버로 만들어서 간편하게 접근할 수 있을 것 같았기 때문이다.

특징
1) 생성자를 private으로 선언하여, 외부에서 직접 객체를 생성하지 못하게 한다.
   ⇒ 생성자를 private으로 선언하게 되면, 외부 클래스에서 해당 클래스에 접근 하지 못하기 때문에 new함수를 통한 객체를 만들 수 없다.
2) 클래스 내부에서 private으로 선언된 유일한 객체를 만들고 그것을 반환하는 static 메서드를 제공한다.

장점
1) 객체의 중복 생성을 절대적으로 방지하고, 생성된 객체를 재사용하기 때문에, 메모리 낭비를 방지 할 수 있다.
2) 싱글톤으로 생성된 객체는 전역성을 가지고 있기 때문에 어디서든지 쉽게 그 객체에 접근 할 수 있다.

여러가지 구현 방법
1) 게으른 초기화

![Untitled](https://github.com/COW-edu/COW-Spring-2/assets/120346721/2b4a337a-21a1-449c-907b-7032ad5518c4)

   ⇒ 여기서 synchronized를 사용한 이유는, 멀티 Thread를 사용하는 환경에서 한 가지 Thread가 이 메서드에 접근한다면, 그것의 처리가 다 끝날 때까지 다른 Thread에서 접근 하지 못하도록 하기 위한 동기화이다.

    2) 정적 변수 선언에서 초기회

![Untitled 1](https://github.com/COW-edu/COW-Spring-2/assets/120346721/89a2f467-ff64-463b-8d97-32ebe483a641)


   ⇒ 이것도 굉장히 좋은 방법이지만, 쓰레드의 안정성을 보장 할 순 없다.

    3) holder에 의한 초기화

![Untitled 2](https://github.com/COW-edu/COW-Spring-2/assets/120346721/80cf8861-24bd-4639-a134-e2e77e5c6ccc)


   ⇒ 이것은 getInstance라는 static 메서드가 호출될 때, 내부 클래스인 Initialization이 로딩이 되고, 그때 instance가 초기화가 된다. 그렇기 떄문에 Holder_Initialization의 객체가 그때 딱 한번만 생성이 된다. 그리고 그것을 반환하게 된다. 즉 return을 할 때마다 new를 하는 것이 아니고, 그것이 맨 처음에 호출이 되었을 때 그때 이미 초기화가 이루어져있고 그 정적 변수에 접근하고 반환하는 것이다.

   ※클래스 로딩
   클래스 로더가 .class 파일을 찾고 그것을 JVM의 메모리에 올리는 것을 의미한다.
   실행이 되면 모든 .class파일이 JVM에 올라가지 않고, 사용될때에만 올라가기 때문에 메모리와 클래스를 효율적으로 사용할 수 있다.

   클래스 로딩 시점

    - 클래스의 인스턴스 생성
    - 클래스의 정적 변수 사용 ( 단, 정적 변수가 final이 아닌 상수일 때만 그렇다)
    - 클래스의 정적 메소드 호출

   초기화
   클래스 초기화란 static 블록과 static 멤버 변수의 값을 할당하는 것을 의미한다.
   내부 클래스는 초기화 대상이 아니다.

    - 클래스의 인스턴스 생성
    - 클래스의 정적 메소드 호출
    - 클래스의 정적 변수 할당
    - 클래스의 정적 변수 사용 (final이 아닌 경우)

   클래스 로딩이 일어날 때 초기화도 같이 일어난다고 볼 수 있다.
   초기화되는 순서로는  static 블록 → 정적 변수 → 생성자 순이다.

![Untitled 3](https://github.com/COW-edu/COW-Spring-2/assets/120346721/4d881632-de9e-4b73-a0b8-70264f13983b)


   출처: [https://velog.io/@skyepodium/클래스는-언제-로딩되고-초기화되는가#2-왜-올려-놓는가](https://velog.io/@skyepodium/%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%96%B8%EC%A0%9C-%EB%A1%9C%EB%94%A9%EB%90%98%EA%B3%A0-%EC%B4%88%EA%B8%B0%ED%99%94%EB%90%98%EB%8A%94%EA%B0%80#2-%EC%99%9C-%EC%98%AC%EB%A0%A4-%EB%86%93%EB%8A%94%EA%B0%80)


1. **싱글톤 컨테이너란?( 싱글톤의 단점)**
   싱글톤 컨테이너는 사용할 객체들을 싱글톤 패턴으로 생성하고 관리하는 컨테이너를 뜻한다. 애플리케이션에서 필요한 객체를 중앙에서 생성하고 공유함으로써 객체의 생성과 관리에 대한 일관성과 효율성을 제공합니다.
   이것은 개발자가 직접 구현 할수도 있지만, 주로 프레임워크에서 제공이 된다. 스프링에는 스프링 컨테니어라는 것이 존재한다. 그것은 싱글톤 컨테니어의 역할을 수행할 수 있다.

단점
1) 내부 상태를 변경하기 어렵다.
   ⇒ 싱글톤 객체를 수정할 경우, 모든 곳에서도 똑같이 그 변경에 영향을 받기 때문에 쉽게 변경하기 어렵다. ( 싱글톤 객체안에 공유되는 필드의 값이 변경될 때 작업들이 꼬일 수 있다. A라는 작업을 통해 어떤 필드값이 할당이 된 상황에서, B라는 작업을 통해 그것이 변경이 되어야 했는 데 B에서 값을 가져오지 않았고, 그래서 C라는 작업을 할 때 B작업을 통해 얻어온 값이 없어서 예외가 발생해야 하는 데, A라는 작업때문에 엉뚱하게 예외가 발생하지 않고 실행 될 수 있다.)
2) 싱글톤 객체를 사용하는 객체 간의 결합도가 높아진다.
   ⇒ 객체 간의 결합도가 높아진다는 것은 객체 지향 개발 원칙의 Solid의 O인 개방 폐쇄의 원칙을 어길 수 있다.
2. **JAVA의 POJO란 무엇인가?( feat. Spring의 Bean)**
1) POJO란
   Plain Old Jaa Object로, 오래된 방식의 간단한 자바 오브젝트라고 볼 수 있다. 아니면 특정한 제약이나 프레임 워크에 종속되지 않는, 순수하게 자바 언어로 작성된 객체를 의미한다. 그리고 스프링에서의 Bean은 POJO이다.

   ![Untitled 4](https://github.com/COW-edu/COW-Spring-2/assets/120346721/3a861068-6e1e-4d98-828d-1309ba83cb9e)

   ⇒ 이것이 POJO의 예시이다.

   ![Untitled 5](https://github.com/COW-edu/COW-Spring-2/assets/120346721/3d4adc1e-9c1c-4ef9-9633-1dd736d1ed80)

   ⇒ 이것은 반대 예시이다.

    2) POJO가 나타나게 된 이유
       스프링 프레임워크 이전에는 엔터프라이즈라는 기술이 존재했다. 그것을 사용하기 할 때, 그것의 특정 기술과 환경에 종속되어 의존하게 되어 자바 코드의 가독성이 떨어지고 유지보수에 어려움이 생겼다. 그래서 본래 자바의 장점을 살리는, 오래된 방식의 순수한 자바 객체를 사용하게 되어서 그것을 POJO라고 불렀다.

    3) POJO의 제약 사항

    - 미리 지정된 클래스를 extend 해서는 안된다.
    - 미리 지정된 인터페이스를 implement 해서는 안된다.
    - 미리 정의된 어노테이션을 포함해서는 안된다.

    4) 진정한 POJO?
       : 위에 사진으로 POJO와 그것이 아닌 것의 예를 올렸지만, 계속 찾아본 결과 POJO를 나누는 명백한 기준이 애매한 것 같다. 그래서 POJO라는 것은 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트라고 토비라는 사람이 언급을 했다. 이것은 객체 지향 언어의 장점과 예전에 엔터프라이스 기술을 사용했을 때의 힘듦을 잊지 말라는 것 같다.

    4) 스프링 Bean
       스프링에서 Bean은 스프링 컨테이너에 의해 관리되는 객체를 의미한다.

3. **스프링의 사용 이유, 장점이나 특징**

스프링은 자바를 기본으로 하는 오픈 소스 프레임 워크이기에 자바 언어의 강력한 특징중 하나인 객체 지향적으로 프로그래밍 할 수 있게 해준다. 스프링을 사용하게 된 이유는 예전에 많이 사용되었던, Enterprise Java Bean의 복잡성 때문에 나왔다고 볼 수 있다. EJB을 사용하기 위해서 만든 객체들이 그것에 너무 의존해야하고 종속되게 만들어야 하기 때문에, POJO가 나오게 되었고, POJO로만 SOLID를 지키면서 프로그래밍 해보니까, 나오는 공통적인 코드들을 모아서 스프링이라는 프레임 워크를 만들게 된 것이다. 즉 스프링은 객체 지향의 5원칙인 SOLID중에 OCP와  DIP를 지켜주기 위해서 만들어졌다. 스프링은 DI 컨테이너를 제공한다. (DI는 의존 관계, 의존성 주입을 의미한다.) 이것을 통해 우리는 OCP와 DIP를 지킬 수 있게 된다.

OCP(Open/Close Principle)
확장은 열려있지만, 변경에는 닫혀있어야 한다는 원칙이다.
확장을 할 때는 코드의 변경이 이루어지지 않아야 한다는 것 처럼 보이지만, 그것이 아니라 다형성을 잘 활용하라는 말이다.
만약 클라이언트에 바로 Car car = new Car(); 이런식으로 구현을 한다면, 클라이언트의 코드는 car에 맞춰줘서 코드가 짜여졌을 것이다. 하지만 여기서 만약 일반 차가 아니라 자전거라는 기능을 확장을 해야한다면, Car car = new Car(); 가 아예 바뀌어야 하고, 그 소스코드의 방향도 아예 바뀌어야 할 것이다. 하지만 Ride ride = new Car(); 이런식으로 탈 것이라는 인터페이스로 car를 담는 다면, 자전거라는 기능을 추가해도 Ride ride = new ??()로 해주기만 하면, 변경이 크게 되지 않는 다. 하지만 이것도 완벽한 OCP를 지킨 것이 아니다. 사용할 구현체가 바뀌면 클라이언트 내에서 바꿔줘야 하기 때문이다. 그래서 스프링의 DI로 그것을 해결해줄 수 있다.

DIP(Dependency Inversion Principle)
의존 관계 역전의 원칙으로, 프로그래머는 구현체를 바라보는 것이 아니라 추상화를 바라봐야 한다는 것이다. 실제 코드에서 사용되는 건 모두 다 추상화된 것들이여야 한다는 의미이다. 하지만 위에서 보았듯이, 어쩔 수 없이 new Car() 처럼 실제 구현체를 의존할 수 밖에 없다. 그래서 스프링이 이것을 해결해주기 위해 나온 것이다.

스프링이 이러한 것들을 지켜줄 수 있는 이유는, IoC 컨테이너가 존재하기 때문이다. Ioc(Inversion of Control) 컨테이너를 제공해서, 객체의 생성과 관리를 개발자가 아닌 스프링 컨테이너에게 위임하여, 객체 간의 의존성을 줄이고, 유연한 개발을 할 수 있게 해준다. 또한 DI라는 의존성 주입을 스프링 컨테이너에서 일어나기 때문에, OCP, DIP를 지킬 수 있게 된다.

또 스프링은 데이터 베이스 연결 환경이라든지, 트랜잭션 관리, 보안등을 다양한 환경 설정을 제공 하고 또 그것들은 설정파일(XML, 자바 설정 클래스)를 이용해서 관리가 되어 진다.

4. **스프링에서 사용되는 어노테이션 10개 이상 정리하기
1) @Component**
   개발자가 생성한 클래스를 Spring bean으로 등록할 때 사용 되어지는 어노테이션이다.  스프링은 해당 어노테이션으로 그 클래스를 Spring bean으로 등록한다.
   스프링 애플리케이션이 시작이 될 때 자동으로 컴포넌트 스캔이 일어난다. 그때, 스프링 컨테이너가 생성이 되고, Component가 붙은 클래스를 스프링 컨테이너에 bean으로 등록을 한다.

**********2) @Configuration**********
이 어노테이션이 붙은 클래스는 스프링 컨테이너가 인식할 수 있는 설정 클래스가 된다. 이 클래스가 스프링 컨테이너 역할을 하는 것은 아니고, 스프링 컨테이너에 의해 의식이 되고, 스프링 컨테이너한테 그 클래스 안에있는 설정 정보를 기반으로 Bean들을 생성하고 관리하게 해줄 수 있다.
그 뿐만이 아니다. 이 Configuration으로 bean이 싱글톤 패턴을 유지할 수 있게 한다. Configuration없이 그 클래스 내에 bean으로 빈을 수동 등록한다면, 여러개의 빈이 생성된 수 있다. 하지만 Configuration이 붙은 클래스를 사용한다면, 이미 스프링 빈이 존재하면, 존재하는 빈을 반환하고, 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어진다. 그래서 싱글톤이 보장 되는 것이다.
**************3) @ComponentsScan**************
이 어노테이션은 Comfiguration이 붙은 클래스에 붙이는 데, 해당 클래스에 있는 Bean을 스프링 컨테이너에 등록할 수 있다. @Component 어노테이션 말고도 그것을 상속한 @Controller, @Service, @Repository가 붙은 클래스를 자동으로 Scan해서 Bean으로 등록해주는 역할을 한다.
******4) @Bean******
수동으로 스프링 컨테이너 Bean을 등록하는 방법이다.
개발자가 직접 제어가 불가능한 외부 라이브러리를 Bean으로 만들 때 사용되어 진다.
만약 클래스에 1개 이상의 @Bean이 존재한다면, 그 클래스에 @Configuration을 명시해야 싱글톤이 보장된다.

※@Component와 @Bean의 차이점
@Component는 클래스에 명시되고, @Bean은 메서드에 명시가 된다. @Component가 명시가 된 클래스는 스프링 컨테이너가 해당 클래스를 스캔해서 자동으로 빈으로 등록하고, Bean은 개발자가 직접 명시한 Bean만을 등록한다.

******5)@Controller******
웹 애플리케이션에서 Controller의 기능을 할 수 있게 해주는 어노테이션이다. 이것은 MVC 패턴중 Controller를 명시한다. 그래서 클라이언트의 HTTP 요청을 처리하고 응답을 생성해서 반환하는 클래스이다.
이 어노테이션을 사용하게 되면, **@GetMapping, @PostMapping, @RequestParam, @ModelAttribute** 같은 어노테이션을 사용할 수 있고 그것으로 클라이언트의 요청을 받고 결과값을 url로 반환할 수 있게 된다.

****6)@RequestMapping****
이것은 클래스나 메서드에 둘다 부착이 된다. 클래스에 부착한다면, 하위 메소드에 모두 적용이 되고 메소드에서 적용이 될때는 해당 메소드에서 지정한 방식으로 url을 처리한다. 실제 모습으로는 @RequestMapping(value=” ”) 이렇게 괄호안에 value값이 넣고, 만약 들어온 요청의 url의 Path와 value값이 일치한다면 메서드가 실행되는 형식이다.

그리고 추가적으로 중요한 것은 이것들은 다
url의 요청을 받는 건데, RequestMapping을 사용해서 Path의 경로가 일치하는 요청을 구별해서 받아온다고 했지만, 그 path에서 각기 다른 파라미터 값을 보내는 요청이 있을 수 있다. 그때 **`@RequestMapping(value = "/user", params = "nickname")`** 이렇게 어노테이션 매개변수 안에 params 라는 것을 넣어서 파라미터에 따른 요청도 구별해 줄 수 있다.

****7)@RequestHeader****
클라이언트의 요청(HTTP)의 헤더 값을 가져올 수 있다.
*`@*Controller`

    *`@*RequestMapping("/user")`     
    
    `public class UserController {*@*RequestMapping(method = RequestMethod.GET)`
    
    `public String getUser(*@*RequestHeader(value="everyThing") String paramehter)` 
    
    여기서 보면 @RequestHeader은 매개변수로 들어간 것을 볼 수 있다.
    
    value의 값은 아무거나 들어가도 상관이 없다. 어처피 @RequestMapping 어노테이션 안에 있기 때문에 올바른 헤더값이 무조건 paramether에 들어간다. 하지만 Accept를 많이 사용하는 것 같다.
    
    ※ HTTP의 헤더와 바디
    HTTP 요청은 헤더와 바디로 나뉘어 진다. 
    
    헤더에는 요청에 대한 메타데이터가 포함되어있다. 요청 바디의 데이터 유형(JSON, XML,등), 요청 바디의 크기, 클라이언트의 인증 정보(토큰, 사용자 아이디 비번), 클라이언트 애플리케이션이나 브라우저의 식별자 등이 포함되어 있다.
    
    바디에는 실제 데이터 내용이 들어가있다. 클라이언트가 서버로 전송하고 싶어하는 내용이 담겨있다. 웹 API인 경우 JSON 형태로 데이터를 보낼 수 있고 파일 업로드인 경우 바이너리 데이터가 요청 바디에 포함될 수 있다.
    
    ******8)@RequestParam******
    
    ![Untitled 6](https://github.com/COW-edu/COW-Spring-2/assets/120346721/ac4466b9-2af7-45ec-aae7-3c319d45dffd)

    
    위에서 이미 RequestMapping이 파라미터에 대한 요청을 구별하는 것을 알았다. 이것은 그렇게 받아온 파라미터를 처리하기 위해 존재한다. 받아오는 것에는 두 가지 방식이 존재하는 데, 파라미터 이름과 매개변수 이름이 동일할 경우엔 저렇게 바로 String nickname으로 받아서 nickname에다가 담기게 하고, 만약 다르다면, old라는 파라미터의 값을 age에 담아서 age라는 매개변수로 사용하게 된다.
    
    ****9)@RequestBody****
    클라이언트가 보내는 요청의 body를 받아온다. 메서드 안에 매개 변수로 넣어지는 데,
    `public String add(@RequestBody User user)`
    `user.name;`
    이런식으로 접근이 가능하다. 이렇게 또 접근이 가능한 이유는 클라이언트의 요청이 JSON이나 XML과 같은 형태로 전송되기 때문에 이런식의 접근이 가능하다.
    
    **10)@ResponseBody**
    이것이 사용되는 메서드는 리턴되는 값이 View로 출력되는 게 아니라, HTTP Response Body에 직접 쓰여진다. 즉 페이지가 반환되는 게 아니라, JSON이나 XML 같은 데이터를 리턴한다.
    이걸 반환하는 이유는 REST ful 방식에서는 클라이언트가 JSON이나 Xml같은 데이터들을 받아오고, 클라이언트가 그것에 대한 처리를 수행하거나, 화면에 적절히 보여준다. REST ful API는 데이터를 주고받는 API라고 생각하면 된다. 반환값이 HTML 같이 페이지라면, 그것은 전통적인 웹 방식이고, 이 어노테이션을 사용한거면 REST ful API 방식으로 데이터를 주고 받기 위함이라고 이해하면 된다.

5. ****controller - service - repository란?****
1) Controller:
    - 사용자의 요청을 구분하고, 거기에 맞는 응답을 반환하는 역할을 담당한다.
    - 그 요청을 처리하는 service의 메서드를 호출한다.

    2) Service

    - 비즈니스 로직을 수행하는 역할을 담당한다.
    - Repository로부터 받아오는 데이터들을 처리, 계산, 외부 시스템과의 상호작용등을 수행한다.
    - 일반적으로 서비스는 트랜잭션 경계를 설정하고, 비즈니스 로직을 수행하는 데 사용한다. ( 트랜잭션 알아오기)

    3) Repositroy

    - 데이터베이스나 다른 저장소에 있는 데이터를 읽고 쓰는, 데이터 엑세스 작업을 수행합니다.
    - 즉 데이터베이스와의 상호작용( Create, Read, Upadate, Delete)의 작업을 제공한다.
    - 일반적으로 ORM 기술을 사용해서 데이터베이스의 상호작용을 처리한다. (ORM 찾아보기)

이것은 MVC 패턴과 유사해보이지만, MVC 패턴은 애플리케이션의 구조를 조직화하는 소프트웨어 디자인 패턴이다.

하지만 이것은 스프링 프레임 워크에서 주로 사용되는 구성 요소를 의미한다. 그래서 스프링의 DI 기능을 활용해서 각 역할에 맞게 나눈 것이 Controller - Service - Repositroy 인 것 같다.
## 7주차 학습 PR

### 싱글톤 패턴이란?
싱글톤 패턴은 객체의 인스턴스가 오직 1개만 생성되는 것을 보장하는 패턴이다. 싱글톤 패턴의 장점으로는 우선 메모리의 효율이 있다.
객체의 인스턴스가 필요할 때마다 새로 생성하지 않고 하나의 인스턴스만을 사용하기 때문에 메모리 낭비를 방지할 수 있다. 두번째는 
데이터 공유에 있다. 싱글톤 패턴을 통해 인스턴스를 생성할 때엔 static으로 생성하기 때문에 다른 클래스들의 인스턴스에서도 데이터를
공유할 수 있다. 하지만 이에 따른 단점으로 Race Condition이 발생할 수 있다. Race Condition은 공유된 데이터에 동시에 여러 개의 
간섭이 들어오게 될 때 실행 결과가 변질될 수 있는 상태를 뜻한다. 예를 들어 3이라는 값을 가진 int a에 대하여 2를 더하는 함수와 4를
더하는 함수가 동시에 실행되었다고 가정해보자. a라는 데이터에 특정 값을 더한다는 것은 간단하게 세 단계로 나누어 볼 수 있다. a가 
가리키는 주소의 값(3)을 가져온다. 그 값에 특정 값을 더한다. 더한 값을 a가 가리키는 주소에 저장한다. 만일 두 함수가 순차적으로 
진행된다면 a에는 9라는 값이 남겠지만 병렬적으로 진행될 경우 변한 값이 저장되는 과정이 이루어지기 전에 다른 함수의 a의 값을 읽는 
과정이 진행되어 한 함수로 인해 a의 값이 변경되더라도 남은 함수는 변경 전 a의 값에 특정 값을 더하고 그 결과를 저장하게 된다. 이럴
경우 결과적으로 병렬적을 진행된 함수 중 아주 미세한 차이라도 늦게 저장하는 쪽의 결과만이 남고 선행된 함수의 변경은 없는 것과 다름 
없어진다. 때문에 싱글톤 패턴을 사용한다면 이러한 동시성 문제를 해결해야 한다. 또한 클래스 간의 결합도를 높일 여지가 크다는 문제 또한 
존재한다. 또한 클라이언트가 인터페이스와 같은 추상화가 아닌 구체 클래스에 의존하게 된다. 이는 의존 역전 법칙(DIP) 또한 위반한다. 
그리고 단위 테스트에 적합하지 않다. 단위 테스트는 테스트가 서로 독립적이어야만 그 의미가 있다. 하지만 자원을 공유하기 때문에 단위 
테스트를 하기 위해서는 관련된 인스턴스의 상태를 모두 초기화해야 한다.

### 싱글톤 컨테이너란?
자바 스프링에서는 컨테이너를 통해 객체를 관리한다. 이 때 이 컨테이너가 객체 인스턴스들을 싱글톤으로 관리한다. 이때 이 컨테이너를 
싱글톤 컨테이너라고 한다. 컨테이너는 싱글톤 패턴처럼 객체를 필요할 때마다 생성하는 것이 아니라 생성해둔 객체를 공유하여 재사용한다. 
이러한 싱글톤 방식을 사용하기 위해서는 @Configuration 어노테이션을 클래스에 붙이고 내부에 @Bean을 통해 등록하면 된다. 싱글톤 
컨테이너를 사용할 때에는 필드에 상태를 유지할 수 있는 필드가 존재하면 안된다. 예를 들어 int a라는 필드가 존재한다면 이 필드에 값을 
저장하는 함수 두 가지가 실행될 때 같은 인스턴스를 공유하기에 후에 실행된 함수의 값만이 남게 된다.

### JAVA의 싱글톤 VS 스프링의 싱글톤
- 구현 방식
  자바의 싱글톤은 클래스 로더에 의해 구현된다.
  생성자를 private로 하여 외부에서 생성되는 것을 방지하고 참조를 static으로 하여 외부, 내부에서 접근할 수 있게 한다.
  스프링의 싱글톤은 스프링 컨테이너에 의해 구현된다.
  @Configuration과 @Bean을 사용한다.
- Scope
  자바의 싱글톤의 scope는 코드 전체이지만 스프링의 싱글톤의 scope는 해단 컨테이너 내부로 제한된다.
- Thread-Safety
  자바의 싱글톤은 로직을 어떻게 구현하는지에 따라 Thread-Safety를 	보장할 수도 있고 보장하지 않을 수도 있다. 하지만 스프링의 싱글톤은 자동으로 Thread-Safety를 보장한다.

### Java의 POJO란 무엇인가?
POJO는 Plain Old JAVA Object의 약자로 뜻 그대로 오래된 순수한 자바 객체라는 뜻이다. 이는 환경과 기술에 종속되지 않은 순수 자바 객체를 
뜻한다. 여러 프레임워크가 개발되며 이 프레임워크를 사용하기 위해서 해당 프레임워크에만 사용 가능한 즉, 프레임워크에 종속된 객체들을 
만들어야 했다. 이러한 경우 종속된 프레임워크가 아닌 다른 프레임워크나 환경에서는 작동이 불가능한 상황이 나오게 되었다. 즉 객체지향의 
절대 강점인 재사용성이 저하되는 것이다. 이 때문에 POJO라는 개념이 등장하게 된 것이다. 스프링은 POJO를 지향하는 프레임워크이다. 이를 
위해 스프링에서는 IOC, AOP, PSA를 지원한다. IOC는 Inversion Of Control의 약자로 메소드나 객체의 호출을 개발자가 결정하는 것이 아니라 
외부에서 결정하는 것을 뜻한다. 객체의 의존성을 역전시킴으로써 객체 간의 결합도를 줄일 수 있다. AOP는 Aspect Oriented Programming의 
약자로 관점 지향 프로그래밍이라는 뜻이다. AOP는 OOP(객체지향 프로그래밍)의 단점을 개선하기 위해 등장하였다. 객체지향 프로그래밍은 객체를 
재사용할 때 객체들 간 공통된 로직이 존재할 수 있다. 이 때 이 로직들이 객체마다 반복되어 유지보수에 비효율적이다. 이를 보완하기 위해 이 
반복되는 로직을 모듈화하여 사용하는 것을 AOP라고 한다. 스프링에서의 AOP는 프록시 패턴을 사용한다. 프록시 패턴이란 원본 객체를 대신하여 
처리하는 대리인(프록시)를 만들어 로직의 흐름을 제어하는 패턴이다. 이 패턴은 객체가 민감한 정보를 가지거나 인스턴스화를 하기엔 무거운 
경우와 같이 객체 생성 시 비용이 큰 경우 사용한다. 프록시는 내부 캐시를 사용하여 데이터가 존재하지 않을 때 객체를 사용하는 캐싱, 객체에 
대한 데이터 유효성 검사, 객체 생성 비용이 비쌀 때 생성을 필요 시까지 연기하는 지연 초기화 등 여러 부가기능 또한 지원한다. 스프링은 공통 
함수를 통해 만든 모듈을 프록시로 사용한다. PSA는 Portable Service Abstraction의 약자로 서비스를 추상화하여 개발자에게 편의성을 제공해주는 
구조이다. PSA를 통해 환경의 변화와 관계없이 일관된 방식의 접근을 가능케한다. 이러한 방법들을 통해 스프링은 POJO를 지원하고 있다.

### 스프링의 사용 이유, 장점이나 특징
스프링은 트랜잭션을 지원한다. 트랜잭션이란 DB의 상태를 변화시키기 위해 수행하는 작업의 단위를 의미한다. 쉽게 CRUD를 생각할 수 있다. 하지만 
이때 작업의 단위는 하나의 행동을 의미하지 않는다. 예를 들어 DB의 데이터 중 하나의 값을 변경하여 저장하고자 한다면 데이터 선택, 값 변경, 
저장이 하나하나의 트랜잭션이 되는 것이 아니고 그 모든 과정이 하나의 트랜잭션이 되는 것이다. 트랜잭션은 4개의 특징을 가진다. 첫번째는 원자성으로 
트랜잭션이 DB에 모두 반영되거나 아예 반영되지 않아야 한다. 두번째는 일관성으로 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다. 트랜잭션의 
진행 중 DB에 변경이 있더라도 변경 전 데이터베이스에 대해 트랜잭션이 진행되어야 한다. 세번째는 독립성으로 둘 이상의 트랜잭션이 동시에 실행될 때 
트랜잭션은 다른 트랜잭션의 연산에 관여할 수 없다. 마지막 네번째는 지속성으로 트랜잭션이 성공적으로 완료되면 결과는 영구히 반영되어야 한다는 
것이다. 스프링은 이러한 트랜잭션을 Annotation이나 XML로 설정할 수 있도록 지원한다.
또한 스프링에는 로그인, 회원가입 같은 기능을 지원하는 Spring Security, DB 관리시스템의 변경에 상관없이 DB를 사용할 수 있게 지원하는 Spring JDBC 등 
다양한 라이브러리를 제공한다. 뿐만 아니라 앞서 설명한 POJO 기반의 구성으로 인해 객체지향적 설계가 가능하며 높은 생산성과 유연한 테스트를 가능케 한다. 
그 외에도 의존성 주입을 통해 결합도를 낮추며 앞서 설명한 AOP의 지원으로 반복적인 코드를 줄이고 핵심 비즈니스 로직에 집중할 수 있게 한다. 또한 MVC 
구조를 통해 유지보수에 용이하다 그리고 WAS(Web Application Server)에 독립적인 개발 환경을 가진다. 기본적으로 Apache Tomcat을 내장하고 있기 때문에 
간단히 웹서버를 실행할 수 있다.

### 스프링에서 사용되는 어노테이션 10개 이상 정리하기
@Controller 스프링 웹 서블릿에 의해 웹 요청을 처리하는 컨트롤러 빈으로 선정
@RestController View로 응답하지 않는 Controller
@Service 빈 객체로 생성, 내부에서 자바 로직 처리
@Repository DAO 또는 Repository 클래스에 사용, DB나 파일 같은 외부 I/O 작업 처리
@Configuration을 붙이면 AppConfig로 사용, 내부 Bean 싱글톤으로 생성
@Bean 직접 객체를 컨테이너에 등록, @Configuration 내부에서 사용해야 함, 주로 개발자가 직접 제어가 불가능한 라이브러리 등을 등록할 때 사용
@Component Stereo Type(@Service, @Repository, @Controller)으로 분류하기 어려울 때 사용, @Bean과 달리 name이 아닌 value로 이름 지정
@ComponentScan @Component와 Stereo Type(@Service, @Repository, @Controller)를 스캔하여 등록, 스캔 범위 지정 가능
@Autowired 생성자에 지정 시 스프링 컨테이너가 해당 빈을 찾아서 주입, 타입으로 연결
@Qulifier(“a”) @Autowired와 함께 쓰이며 같은 타입의 빈 중 원하는 빈을 주입하기 위해 사용
@Required 빈 클래스 초기화 시 반드시 세팅해야 하는 메소드 정의 시 사용
@Scope 빈의 생명주기 설정
@Lazy 클래스 로드 시 빈 생성이 아닌 사용 시 로딩
@Value properties로부터 값을 가져와 적용 시 사용

### controller - service - repository란?
Controller는 사용자로부터 요청을 받고 해당 요청을 처리하는 담당 서비스에게 처리를 위임하고 처리 결과를 View에게 전달한다. Service는 Controller에 
의해 호출되어 사용자의 요구사항을 처리한다. 만일 DB의 정보가 필요하다면 Repository를 호출한다. Repository는 Service에 의해 호출되어 DB에서 데이터를 
반환한다. Entity에 의해 생성된 DB에 접근하기 위한 메서드들을 사용하기 위한 인터페이스이다.
